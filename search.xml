<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Day 3]]></title>
    <url>%2F2019%2F10%2F04%2F%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%2FDay%203%2F</url>
    <content type="text"><![CDATA[操作系统的基本特征并发（Concurrence） 并发性两个或多个时间在同一时间间隔内发生。在多道程序环境下，并发性是指在一段时间内宏观上有多个程序在同时运行，但在单处理机系统中，每一时刻却只有一道程序执行，故微观上这些程序只能是分时地交替执行。与之区别的是并行性，并行性是指两个或多个事件在同一时刻发生。 共享（Sharing）​ OS环境下的资源共享又称为资源复用，是指系统中的资源可供内存中多个并发执行的进程共同使用。宏观上即限定了时间（进程在内存期间），也限定了地点（内存）。由于系统中的资源远远少于多道程序需求的总和，会形成它们对共享资源的争夺。 因此，系统必须对资源共享进行妥善的管理。由于资源属性的不同，进程对资源复用的方式也不太相同。有两种方式： 互斥共享方式 当进程A要访问某些资源时，必须提出请求。若此时该资源空闲，系统便可将之分配给请求进程A使用。此后若再有其它进程也要访问该资源，只要A未用完就必须等待。仅当A访问完并释放系统资源后，才允许另一进程对资源进行访问。把这种在一段时间内只允许一个进程访问的资源，称为临界资源（或独占资源）。同时访问方式 系统中还有另一类资源，允许在一段时间内由多个进程“同时”对它进行访问。“同时”，在单处理机环境下是宏观意义上的，而在微观下，这些进程对该资源的访问是交替进行的。并发和共享是多用户（多任务）OS的两个最基本的特征。 虚拟（Virtual） 在OS中，把同归某种技术将一个物理实体变为若干个逻辑上的对应物的功能称为“虚拟”。利用时分复用和空分复用技术来实现虚拟。 时分复用技术 利用某设备为一用户服务的空闲时间，又转去为其他用户服务，使设备得到充分的利用。空分复用技术 利用存储器的空闲空间分区域存放和运行其它的多道程序，以此来提高内存的利用率。虚拟的实现，如果采用分时复用的方法，即对某一物理设备进行分时使用，设N是某物理设备对应的虚拟的逻辑设备数，则每台虚拟设备的平均速度必然等于或小于物理设备速度的1/N。类似地，如果利用空分复用的方法实现虚拟，此时一台虚拟设备平均占用的空间必然也等于或低于物理设备所拥有空间的1/N 异步（Asynchronism） 进程的异步性是指进程是以人们不可预知的速度向前推进的。只要在OS中配置完善的进程同步进制，且运行环境相同，则作业即经过多次运行，也都会获得完全相同的结果。因此异步运行方式是允许的，而且是操作系统的一个重要特征。————————————————版权声明：本文为CSDN博主「WYFVV」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/WYFVV/article/details/86301050 请你解释为什么会出现4.0-3.6=0.40000001这种现象？Java浮点数的内存存储https://www.cnblogs.com/loren-Yang/p/7519593.html 十进制小数如何转化为二进制数 ​ 算法是乘以2直到没有了小数为止。举个例子，0.9表示成二进制数 ​ 0.9*2=1.8 取整数部分 1 ​ 0.8(1.8的小数部分)*2=1.6 取整数部分 1 ​ 0.6*2=1.2 取整数部分 1 ​ 0.2*2=0.4 取整数部分 0 ​ 0.4*2=0.8 取整数部分 0 ​ 0.8*2=1.6 取整数部分 1 ​ 0.6*2=1.2 取整数部分 0 下面的浮点数为了方便计算 我们取3个字节表示浮点数（第一个字节表示整数部分，第二个字节表示浮点数部分） 4.0的浮点数形式 00000100 00000000 00000000 3.6的浮点数形式 00000011 10011001 10011001（后面的1001是死循环） 小数位的数 每个位都为1的话 对应的就是 0.5（1/2） 0.25（1/4） 0.125（1/8） 0.075（1/16） 我们单独看0.6 小数部分的 后2 个字节 10011001 10011001 第一个1为0.5，第二个一（在第四位）为0.0625，第三个一（在第五位）为0.03125，第四个一（在第八位）为0.00390625，0.0625+0.03125=0.09375 0.09385+0.00390625=0.09765625，如果继续往后加，会无限趋近于0.1（即0.099999999999999999），但不等于0.1 所以最后4.0-3.6=0.4000000(不知道几个0)0001]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>学习日记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域的解决方式]]></title>
    <url>%2F2019%2F10%2F03%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2F%E8%B7%A8%E5%9F%9F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[XSS攻击 https://blog.csdn.net/extremebingo/article/details/81176394 CSRF工具 https://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html]]></content>
      <categories>
        <category>计算机网络</category>
        <category>1 计算机网络概论</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Day 2]]></title>
    <url>%2F2019%2F10%2F03%2F%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%2FDay%202%2F</url>
    <content type="text"><![CDATA[Linux软链接和硬链接 希望你看完之后，可以知道下面几个问题的答案Linux文件系统-EXT 是怎么分配内存空间的硬链接和软链接是干什么的两者的区别是什么 如果想要深入一点的学习Linux文件系统的话，建议先看《Linux编程基础》P98～99页，看下文件系统是如何分块的如果看了这两页书，你就知道inode和数据块是存在哪里的啦进入正题想看短小精悍介绍的，看这里，够应付面试-&gt;https://icebearice.gitee.io/2019/05/06/Linux/Linux%E7%A1%AC%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%BD%AF%E9%93%BE%E6%8E%A5/ 想看深入了解的，看这里，够详细-&gt;https://www.cnblogs.com/crazylqy/p/5821105.html GCC的过程看《Linux编程基础》P30页最上面，写得清清楚楚 我能补充书本上面没有的就是命令了 第一步：预处理 gcc -E 生成后缀.i的文件 （一般不生成） 第二步：编译 gcc -c 生成后缀.o的文件 第三步：汇编 gcc -S 生成后缀.s的文件 第四步：链接 gcc -o 生成后缀.exe 即执行文件啦 百度实在找不到pdf 无法复制 你们看书吧 哈哈哈 进程间的通信机制《Linux编程基础》P143页 慢慢看 线程间的通信机制https://blog.csdn.net/dreamcatcher1314/article/details/79303812 Limit优化https://www.cnblogs.com/icebutterfly/p/9199202.html]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>学习日记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux文件系统-ext2]]></title>
    <url>%2F2019%2F10%2F03%2FLinux%2FLinux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F-ext2%2F</url>
    <content type="text"><![CDATA[Linux文件系统ext2基本结构 操作系统将磁盘上的分区分成同样大小的块进行管理，并为每块磁盘号编号 每个块组包括以下五个部分 超级快 组描述符表 块位图 inode位图 inode表]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019.10.3 问题集]]></title>
    <url>%2F2019%2F10%2F03%2F%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%2F%E6%B8%85%E5%8D%95%2F</url>
    <content type="text"><![CDATA[编程范式命令式编程、声明式编程、函数式编程 https://www.cnblogs.com/sirkevin/p/8283110.html]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>学习日记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Day 1]]></title>
    <url>%2F2019%2F10%2F02%2F%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%2FDay%201%2F</url>
    <content type="text"><![CDATA[Select poll epoll监控socket实现的细节区别 要知道这三个东西是做什么的，首先你要知道几个概念：端（服务端）与端（客户端）之间，通过HTTP（HTTP是TCP/IP的实现）建立连接后，是通过套接字（Socket）进行通信的Socket由IP地址和Port端口组成，可用于描述双方通信进程，所以说，有IP地址和端口，就能找到对应IP的服务器上的服务端口，对应的服务端口进程就会将Socket中的数据进行处理所谓的I/O操作，即为数据的读取与写入，Socket的I/O操作，就是针对Socket内数据的读取与写入Socket的I/O方式有两种：阻塞和非阻塞，非阻塞的模式需要由轮询系统来实现，轮询后，若得到返回值，则完成调用（可以理解为while循环，不断询问）多路复用（I/O multiplexing）其实没有那么复杂，我个人认为这个翻译是有问题的，其实意思是“1个通道，多个socket共同使用”，我觉得应该叫单路复用，为什么叫单路复用呢，一会下面我会贴个图select poll epoll 就是多路复用的三种形式，与非阻塞的轮询结合，形成Socket的多路复用轮询系统普通的非阻塞I/O只会不断轮询一个socket，而多路复用的非阻塞I/O会轮询一个队列的socket 多路复用如下图所示，这就是多路复用，是不是叫单路复用比较好…… 多路复用的调用过程 获得Socket队列 轮询Socket队列，查询是否有已经准备就绪的Socket（准备就绪就是：已经有数据返回，说明正在处理对应Socket的进程，已经处理完对应的Socket了，可以给当前进程处理Socket了） 如有已经准备就续的Socket，则让进程进入对应的Socket进行处理，进程进入阻塞状态 进程处理完毕，寻找下一个准备就绪的Socket，继续处理 三者的区别select队列的维护细节： 将所有需要监控的Socket加入等待队列 进程对Socket进行处理时，需要将Socket移出队列 当Socket被处理完之后，重新加入队列 缺陷：select函数性能不高，因为Socket需要被频繁的加入/移出，因此它监控的Socket数量不能过多，底层规定不能超过1024个；还有一点就是，每次都要去轮询整个队列，找到准备就绪的Socket poll队列的维护细节：poll函数就是在上面的基础上，改成了链表的形式，降低了加入/移出的成本，一个数组的加入删除的时间复杂度为O(n)，一个链表加入删除的时间复杂度为O(1)，只是解决了select的数量限制的问题，还是需要通过轮询的形式取Socket epoll队列维护细节：epoll函数通过维护一个eventpoll对象的就绪队列（在队列中的，都是 已经准备就绪的 Socket），每次都只需要直接取就绪队列的第一个Socket即可 三者取Socket的时间复杂度：select-O(n) poll-O(n) epoll-O(1) Socket与进程（服务）的关系 进程可以在客户端，也可以在服务端所有的进程都是通过IP/PORT来确定Socket的 假设只有一个客户端和一个服务端，假设双方的启用端口都是80，则对应的都有一个socket，端口都是80 （192.168.1.1:80） （192.168.1.2:80） 如果有多个Socket（不同port端口）的话，就鱼龙混杂了，因为不同端口可能对应着不同的服务，我们是通过Socket的端口来确定对应的服务的，（就好比 192.168.1.1:3306 用于MySQL服务，196.168.1.1:6379 用户Redis服务） 为什么叫非阻塞多路复用呢阻塞模式下，一个进程只能对应一个Socket，如需监控多个Socket，需要新建多个进程，这和Socket的系统调用命令read/write/send/recv/connect有关，他们都是阻塞调用的，只能够监控一个Socket 非阻塞模式下，一个进程可以同时监控多个Socket，引入队列（列表）的形式，同时监控多个Socket Socket网络编程还有好多知识，讲不来，有兴趣自己去看谢嵘的那本Socket网络编程 参考链接： https://www.jianshu.com/p/37a2bb9d1cae 参考书籍：《Linux编程基础》 B树和B+树的区别B树：首先要阶数为M，M阶B树，每个节点的关键字的个数最大值为M-1最小值为M/2（向上取整）再-1，可以有的子节点为三个，每个子节点的关键字的个数限制与父节点相同，当节点的关键字的个数达到M个时，树中的节点的结构是需要调整的，或先是往上改变父节点的关键字，再是往下，添加B树的层数，保持B树的平衡，性能相当于二分查找 B+树：基本相同，区别为：每个关键字都只用来索引，不存放数据；所有数据都保存在叶子结点中；为所有叶子结点存放一个链指针，链接所有的叶子结点；相比B树来说，更适合做文件索引系统，效率高的原因是减少了IO，减少了盘快读取的次数，减少了IO次数 B*树：就是在B+树的基础上，在非根非叶子结点间添加一个指向兄弟的指针，当节点满的时候，会直接移动到兄弟节点上去，空间利用率更高，分配新节点的概率较低，效率也有所提升 https://yq.aliyun.com/articles/38345 B树和B+树的插入、删除图文详解：https://www.cnblogs.com/nullzx/p/8729425.html 深拷贝与浅拷贝System.arraycopy() 浅拷贝 Arrays.copyOf() 底层调用arraycopy 深拷贝 http://baijiahao.baidu.com/s?id=1639373055719110771&amp;wfr=spider&amp;for=pc IOBIO 同步阻塞 进程发起IO请求后，必须等待IO操作的完成，只有完成了IO操作，用户进程才能运行，Java传统的IO模型就是基于这种方式 NIO 同步非阻塞 进程发起IO请求后，可以做别的事情，用户进程需要不断的询问IO操作是否就绪，这就需要用户不断的询问，从而引入了不必要的CPU资源浪费 可以理解为while死循环 闻到了 才退出 AIO 异步非阻塞 进程发起IO请求后，不等内核IO完成操作，等内核完成IO操作后，通知应用程序，我完成了IO操作，异步操作，异步是通过回调函数callback实现的 就是 方法完成了之后 会告诉方法执行者 我完成 Java的IOJava BIO 同步阻塞 假设一对客户端和服务端，当客户端发出请求，服务端就会启动一个线程进行处理，这个连接如果不做任何事情，就会造成不必要的线程开销，可以通过线程池（先帮你预热好线程，创建好，直接从线程池中拿，就行了）的机制改善 Java NIO 同步非阻塞 客户端的连接请求会注册到多路复用器上，多路复用器会轮询判断连接的IO请求时才能启动一个线程进行处理。用户进程也需要不断的询问IO操作是否就绪 Java IO Multiplexing 多路复用 异步阻塞Selector 不等内核IO操作的完成 等内核IO操作完成时会通知 阻塞的原因是因为时通过系统调用的select和epoll实现的jdk7后 都是epoll实现的 Java AIO 异步非阻塞 非多路复用的形式 就是等通知 https://snailclimb.gitee.io/javaguide/#/java/BIO-NIO-AIO HashCode为什么以一定是2的次幂从两个角度讲： 1 index是如何定位的 2 扩容是怎么扩容的 (看链接)http://www.cnblogs.com/chengxiao/p/6059914.html#t3]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>学习日记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数学定理复习]]></title>
    <url>%2F2019%2F09%2F15%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%2F%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[###递归定义 当一个函数用它自己来定义时就称为递归 递归调用将反复进行直到基准情形出现，如果基准情形不可能出现，则不可能得到答案 所以，有递归的基本法则两条： 基准情形，必须总要有某些基准的情形，它们不用递归就能求解 不断推进，对于那些要递归求解的情形，递归调用必须总能朝着一个基准情形推进 设计法则，假设所有的递归调用都能运行 合成效益法则，在求解一个问题的同一实例时，切勿在不同的递归调用中做重复性工作]]></content>
      <categories>
        <category>数据结构与算法分析</category>
      </categories>
      <tags>
        <tag>数据结构与算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数学定理复习]]></title>
    <url>%2F2019%2F09%2F15%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%2F%E6%95%B0%E5%AD%A6%E5%AE%9A%E7%90%86%E5%A4%8D%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[指数$$X^aX^b = X^{a+b}\\frac{X^a}{X^b} = X^{a-b}\(X^a)^b = X^{ab}\X^n+X^n = 2X^n\2^n+2^n = 2^{n+1}$$ 对数$$\log AB = \log A + \log B \\log \frac{A}{B} = \log A - \log B \\log (A^B) = B\log A \\log A &lt; A 「对所有的A&gt;0成立」$$ 级数-将数列的项依次用加号连接起来的函数$$\sum^N_{i=0}A^i = \frac{A^{N+1} -1}{A-1}(A &gt; 1)\\sum^N_{i=0}A^i = N + 1(A=1)\\sum^N_{i=0}A^i \leq \frac{1}{1-A}(0&lt;A&lt;1)\\sum^N_{i=1}i = \frac{N(N+1)}{2}\\sum^N_{i=1}i^2 = \frac{N(N+1)(2N+1)}{6}\\sum^N_{i=1}a_i=S_n=\frac{n(a_1+a_n)}{2}=na_1+\frac{n(n-1)d}{2}(等差数列前n项和)\\sum^N_{i=1}a_i=S_n=a_1\frac{1-q^n}{1-q}=a_1\frac{q^n-1}{q-1}=\frac{a_1-a_nq}{1-q}(等比数列前n项和)$$ 例如 2^0+2^1+2^2+2^3就等于2^4 - 1 = 15 求证过程：看书P3页，前n项和为S=1+A^1+…+A^n，AS=A+A^2+…+A^n+1 S-AS即可推导出公式]]></content>
      <categories>
        <category>数据结构与算法分析</category>
      </categories>
      <tags>
        <tag>数据结构与算法分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Docker使用总结]]></title>
    <url>%2F2019%2F09%2F15%2F%E5%AE%B9%E5%99%A8%2Fdocker%2F</url>
    <content type="text"><![CDATA[命令 docker ps docker images docker dockerfile 学习学习 https://www.cnblogs.com/panwenbin-logs/p/8007348.html 容器互联 Docker run 命令学习 -i: 以交互模式运行容器，通常与 -t 同时使用； -t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用； -d: 后台运行容器，并返回容器ID； -p: 指定端口映射，格式为：主机(宿主)端口:容器端口 –restart=always 当docker重启时，容器也随之启动 –dns 默认与宿主一致 –volume , -v: 绑定一个卷 –privileged=true 0.6版本后被引入 可获取root权限 –name=”nginx-lb”: 为容器指定一个名称； 进入容器的四种方式 https://www.cnblogs.com/xhyan/p/6593075.html 我们用exec就好 exit 或者 CTRL+C 即可退出 123456789101112131415161718docker run -d -it \-p 3306:3306 \--privileged=true \-v /Users/icebearice/docker/mysql/conf/mysql5.7.conf:/etc/mysql/my.cnf \-v /Users/icebearice/docker/mysql/data:/var/lib/mysql \-v /Users/icebearice/docker/mysql/logs:/logs \-e MYSQL_ROOT_PASSWORD=520827 \--name mysql5.7 \--restart=always \mysql:5.7.27[root@laoliu conf]# docker ps -aCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESe2c88740425a mysql:5.7 &quot;docker-entrypoint...&quot; 8 seconds ago Up 7 seconds 0.0.0.0:3306-&gt;3306/tcp, 33060/tcp mysql5.7[root@laoliu conf]# docker psCONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMESe2c88740425a mysql:5.7 &quot;docker-entrypoint...&quot; 19 seconds ago Up 18 seconds 0.0.0.0:3306-&gt;3306/tcp, 33060/tcp mysql5.7[root@laoliu conf]#]]></content>
      <categories>
        <category>notFinished</category>
      </categories>
      <tags>
        <tag>notFinished</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaGuide阅读笔记]]></title>
    <url>%2F2019%2F09%2F07%2FJava%2FJavaGuide%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[观开源博客项目JavaGuide，有些比较细枝末节的点，以及自己的延伸思考，想要重点记录一下博客地址：https://snailclimb.gitee.io/javaguide/ Java 程序从源代码到运行一般有下面3步： 从字节码到机器码这一步，JVM类加载器会首先加载字节码文件，然后通过解释器逐行解释执行，称为边解释变执行 JIt和AOt GPL C++ JApplet Char字节大小 不够放 构造器不可以被重写 HotSpot采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是JIT所需要编译的部分。JVM会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9引入了一种新的编译模式AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了JIT预热等各方面的开销。JDK支持分层编译和AOT协作使用。但是 ，AOT 编译器的编译质量是肯定比不上 JIT 编译器的。 JIT就是运行时编译,AOT是运行前编译,一种是动态的形式,一种是静态的形式,Java程序从源码到运行一般分为三步,1 生成Java文件 预处理检查没问题 2 java文件编译成class文件, 2 class文件通过JVM解释成对应机器的机器码而当AOT遇到需要动态类加载的时候的时候,AOT为预先编译, 如果说需要Class.forName的形式 根据类名动态加载类的话,就会导致运行前编译没有考虑到这些需要编译的动态的类,所以AOT的编译质量是不如JIT的 但是速度比JIT快,毕竟预编译嘛 String.intern()方法的目的是为了, 重用一些String对象, 每次调用都会引用最新的相同值不同对象的地址的String,为什么这么说呢,因为当你定义一个String s = “abc” 调用s.intren()理所当然会返回预先定义的对象 而 你在定义一个String s1 = “abc”的话 你会发现 先前调用的intern()存的对象 会等于第二个对象 他会实时的 调用最新的引用 String的使用陷阱当定义一个String是s的内容为”ab” 然后再s 追加一个b 这时候 相当于是 丢弃了ab对象 新建了abc对象 会导致大量的副本字符串 就是被我们丢弃的ab 留在内存里 极其影响程序的性能 StringBuilder与StringBuffer两个都是google引入的类 StringBuffer : 相对而言性能较低 因为在很多其内的方法中有sychonize关键字修饰了 而线程安全就会有锁竞争可能导致程序性能降低 锁竞争为什么会导致性能降低呢?锁竞争发生的前提是多线程并发执行某程序段导致的, 因为在Java持有锁是取决于一个线程是否占有对应程序段的执行权的唯一因素，Java中锁的变化有三种形态： 1 偏向锁：大多数情况下，锁不仅不存在锁竞争，而且总是有同一个线程访问多次获得对应锁，为了让线程更低代价的获取锁，而不是一味的CAS的去加锁解锁，只需访问对象头中和当前线程的栈帧中存放的线程ID，当前线程的栈帧中存放着对应的对应的线程ID，所以我们只需简单的测试一下对象头中存放的线程ID与当前线程中的线程ID是否一致，如果一致则表示线程已经获得了偏向锁，对象偏向对应线程，并将标识为设置为1，如果没有对应上线程ID，则简单测试标志位是否为1，如果为1则再次存储线程ID，让偏向所指向当前线程，如果为0，则CAS竞争锁使用 2 轻量级锁：在执行线程同步的时候，JVM会先将当前线程中的栈帧中创建存储锁记录的空间，并将对象头中的MarkWord复制到锁记录中，会Display Mark Word，使用使用CAS将对象头的锁指针指向到栈帧中锁记录（即对象头存放栈帧中的锁记录的位置），成功则当前线程获取对应的锁，否则则CAS竞争，若产生并发CAS竞争的话，则升级为重量级锁 3 重量级锁：由于不断的CAS自旋锁会不断消耗CPU资源，为了避免无用的CAS，直接上重量级锁，标识为发生变化后，线程会直接阻塞，停止自旋，当占用锁的线程释放锁的时候，会唤醒所有处于阻塞的线程，让他们继续自旋竞争锁 对象头的话，如果对象是非数组类型，则用2个字宽八个字节来存储对象头，每个字宽分别存MarkWord和指向对象数据的指针（对象数据存放在堆中），MarkWord用于存放hashCode和锁信息，锁信息有对应的标志位，轻量级锁为00，偏向所为01，重量级锁为10，11则表示GC位，对象该被回收了 如果是数组类型的话，则多一个字宽，用来存放数组长度，共三个字宽 String Builder : 相对而言性能较高, 但会导致线程不安全 jdk1.5 为了解决效率问题 都继承AbstractStringBuilder 它实现了 CharSequence 表示可读可写的字符串 appendable实现追加操作 charsequence是为了实现可读可写是char数组 而appenadable实现追加操作 String不可变的原因是因为 底层使用了final修饰为什么要有不变模式：？ 1 当对象被创建时，内部数据不再发生变化 2 对象会被频繁的访问，被多线程频繁访问 不变模式是在逃避问题，而不是从解决本质上改变问题，通过投机取巧的形式，用不变模式，解决多线程访问控制的问题 不变模式的实现： 1 去除了setter以及修改自身属性的方法 2 所有属性设为私有 并用final标记，确保不被修改 3 确保没有子类重载 Java中定义一个不做事且没有参数的构造方法的作用如果什么构造方法都不定义，则自动生成一个默认无参构造函数，而如果只定义有参构造的话，是编译不成功的，因为当你未定义无参构造的话，Java则必须要定义一个无参构造，这是一种严谨的思维，免得你没输入参数构造函数，导致程序崩溃 接口的一些问题默认为public，（jdk8之后，接口可以有默认实现，可以定义静态方法），抽象类本身可以有抽象方法，接口相当于默认用abstract修饰，也就是说默认是抽象接口，里面的方法也默认为抽象方法 接口中除了static final变量外，不能有其他变量，而抽象类不一定，因为是类 接口为行为的一种抽象，而抽象类是对类的抽象，所以性质会有所不同 抽象方法可以有很多修饰，例如public default和protected 但是不能用private 用了private 就不能继承了，不能重写方法了，违背了抽象类的原始定义 局部变量不可以用static修饰，没有意义呀，因为static一般是跟着某个方法或者某个类的，是从属的，被static修饰的变量是属于实例的，被static修饰的方法是属于类的，对象存放在堆内存中，而局部变量存放在栈内存中String的搬家历程jdk6之前，存在于的方法区的永久代（永久代是方法去的一个实现，永久代是热点代码的概念，方法区市Java虚拟机中的一种规范）（各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量信息、静态变量、即时编译产生的代码等数据，方法区的大小有限，可以通过相关的JVM参数调节方法区的初始大小和最大大小，垃圾回收行为在方法区会比较少出现，所以才有了方法永久代的说法，因为永久存在）中的运行时常量池（因为是final变量嘛嘛）中。 jdk7后，整个运行时常量池（包含字面量（文本字符串 final常量 基本数据类型的值 ）和 符号引用（类和结构的完全限定名即唯一名字 字段名称和描述符 方法名称和描述符））被转移到堆中，此后常量池的最大容量与堆的大小有关，与永久代无关 jdk8之后，永久代被取消，新增元空间，使用直接内存，妈妈再也不担心我堆溢出了 IO相关 BIO NIO AIOBIO 同步阻塞 进程发起IO请求后，必须等待IO操作的完成，只有完成了IO操作，用户进程才能运行，Java传统的IO模型就是基于这种方式 NIO 同步非阻塞 进程发起IO请求后，可以做别的事情，用户进程需要不断的询问IO操作是否就绪，这就需要用户不断的询问，从而引入了不必要的CPU资源浪费 可以理解为while死循环 闻到了 才退出 AIO 异步非阻塞 进程发起IO请求后，不等内核IO完成操作，等内核完成IO操作后，通知应用程序，我完成了IO操作，异步操作，异步是通过回调函数callback实现的 就是 方法完成了之后 会告诉方法执行者 我完成了 Java的IOJava BIO 同步阻塞 假设一对客户端和服务端，当客户端发出请求，服务端就会启动一个线程进行处理，这个连接如果不做任何事情，就会造成不必要的线程开销，可以通过线程池（先帮你预热好线程，创建好，直接从线程池中拿，就行了）的机制改善 Java NIO 同步非阻塞 客户端的连接请求会注册到多路复用器上，多路复用器会轮询判断连接的IO请求时才能启动一个线程进行处理。用户进程也需要不断的询问IO操作是否就绪 Java IO Multiplexing 多路复用 异步阻塞 Selector 不等内核IO操作的完成 等内核IO操作完成时会通知 阻塞的原因是因为时通过系统调用的select和epoll实现的 jdk7后 都是epoll实现的 Java AIO 异步非阻塞 非多路复用的形式 就是等通知 适用场景： 1 BIO适合连接数目少的固定架构 要求服务器硬件资源较高 jdk4 2 NIO适合连接数目多且较短连接的架构 比如聊天 jdk4 3 AIO适合连接数目多且较长连接的架构 比如相册服务器 jdk7 顺带一提 线程池 emmm 再见 我明天再看吧顺带一提 数据库连接池 常见有 C3P0 Druid的数据库连接池 1 加载jdbc 2 通过jdbc连接数据库 3 访问数据库 执行sql语句 4 断开数据库连接statement和preparestatement的区别 1 pre是预编译，对于批量处理可以大大提升效率 就好比预编译语句 只需传入参数即可 2 statement只执行一次，非批量处理速度比pre快 3 statement会造成sql注入攻击 Socket详解网络编程的核心对象为Socket，创建socket时会在底层文件系统创建一个socket对象，这个对象包括了发送缓存区，接受缓存区，等待队列，recv函数用于某一个socket中接收流量，但这个函数在被调用入进程会一直处于阻塞状态，直到从该socket收到数据为止，recv函数只能控制一个socket，如果有多个socket，则需要多个recv，多个进程，这时候就需要select和epoll同时监控多个socket了 select监控socket的实现细节： 1 把进程加入到socket等待队列中，然后进程由于需要处理这些socket队列，进程阻塞 2 当进程处理完队列中的一个socket之后，将所有的socket从等待队列中移出，并把进程重新加入到CPU工作队列中，让进程就绪 3 进程被CPU调用后，遍历一遍队列，再次寻找有返回数据的socket，继续处理当前数据， 4 然后再次将进程加入队列中，继续进入阻塞状态 由于他会将socket队列中所有socket移出后重新加入队列，性能不高，因此监控的socket数量有限，1024个 epoll监控socket实现细节： 1 epoll的对象eventpoll会维护一个等待队列 2 当对象进入socket队列中，cpu阻塞 3 当socket返回数据时，直接寻找队列中的等待唤醒的进程，继续处理数据 4 被唤醒的进程继续获取socket读取数据 5 操作完数据这些可读数据的socket，就会重复第一步，将进程加入到socket队列中，继续阻塞 epoll的优点：1 epoll不需要频繁的操作所有的socket对象的等待队列，只需操作对象的等待队列即可 2 进程被唤醒后，无需遍历即可知道哪些socket数据是好了的 3 在socket队列中的 都是活跃的 socket 有数据的socket 不会像select一样 需要遍历 无用的socket socket结构：1 addr长度 2 协议簇 说明为ipv6还是ipv4 3 16位端口号 4 32位IP地址 八个0 当我们要将端口号和IP地址进行数据绑定时，将数据赋值给socket 所以socket是用来存放ip和端口的，表示主机的ip和端口，从而判断来源 tansient字段 修饰了 不会被序列化键盘输入的两种方式Scanner input = new Scanner(System.in);String s = input.nextLine();input.close(); BufferedReader input = new BufferedReader(new InputStreamReader(System.in));String s = input.readLine(); Java内存模型 每个线程有每个线程的私有内存空间，而内存与内存之间的交互式通过主内存中的共享内存来实现的，Java中实现线程通信是基于主内存中的共享内存来实现的，并非是消息传递。 故Java的内存模型即为多个线程有自己的私有内存，并且存有共享内存的副本，主内存中存放着共享变量，供线程间通信 Java内存区域 线程私有： 程序计数器 虚拟机栈 本地方法栈 线程共享： 堆 方法区 直接内存 程序计数器较小的内存空间，看作是当前线程所执行的字节码的行号指示器。通过改变这个计数器来选去下一条需要执行的字节码指令。 注意：程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。 虚拟机栈线程私有，Java方法的内存数据，存放方法的局部变量表，另一部分变量在1.6之前存放在永久代，1.8之后存放在堆中。Java虚拟机栈是由一个个栈帧组成，每个栈帧中都有：局部变量表、操作数栈、动态链接、方法出口信息 本地方法栈和虚拟机栈发挥的作用很相似，但是返回的是本地方法服务，即Java调用非Java代码的服务，而虚拟机栈调用的是Java代码的服务 堆内存中最大的一块，有限制，线程共享，存放所有的对象实例、数组（数组也是对象），垃圾回收的主要去处，也称为GC堆，细分为新生代和老年代，新声代有三个空间，eden空间 s0空间 s1空间 老年代为tentird空间，目的是为了更好更快的回收内存用来重新划分分配 方法区方法区是线程共享的区域，存储已被虚拟机加载的类信息、常量、静态变量等 永久代是方法区的一个实现，由于垃圾回收很少在这里行动，所以可以说数据进入方法区就是永久存在了，但是也不是那么绝对 元空间Java1.8之后，方法区被替换成元空间，元空间使用的是本机内存，受本机内存限制，永远不会获得outofmemory，也可以通过对应参数设置元空间大小，jdk7之前，方法区可以通过参数设置大小 运行时常量池包含字面量（文本字符串 final常量 基本数据类型的值 ）和 符号引用（类和结构的完全限定名即唯一名字 字段名称和描述符 方法名称和描述符 jdk1.7之后被移到了堆中 java的8种基本数据类型除了float和double外，常量池内存放了-128～127的常量池数据，预定义 为什么是-128～127 不说了吧 不懂再问我 其实就是方便 Java对象创建的过程1 类加载机制 查看类是否已被加载 解析 或初始化过 没有则进行对应的类加载 2 分配内存 分配方式有指针碰撞和空闲列表 取决于是否规整 未规整则指针碰撞 规整则空闲列表 3 初始化零值 4 设置对象头 对象头有三个部分 上面说了 都要设置好 hashcode gc信息 锁信息 元数据 5 执行init方法 执行初始化 对象的内存布局1 对象头 对象头存放对象自身的存储数据 hashcode 和 锁标志 和分代年龄 这些 和 指向对象实例的指针 2 实例数据为实例 数据为 某些元数据例如属于类的静态变量 方法完全限定名 方法的相关数据 等 3 对其填充部分 对象的起始地址必须是8字节的整数倍 没有数据填满时 要填满补空对齐 为了方便底层内存存储的操作 若有空 则会一定程度上的影响效率 可能会被cpu当作空闲内存来处理 然后引用了假的空闲内存 导致更加多的底层的复杂操作 降低性能 对象访问定位1 句柄 2 直接指针 深度拷贝-System.arraycopy浅度拷贝-Collections.copyB+树和B树B树：首先要阶数为M，M阶B树，每个节点的关键字的个数最大值为M-1 最小值为M/2（向上取整）再-1，可以有的子节点为三个，每个子节点的关键字的个数限制与父节点相同，当节点的关键字的个数达到M个时，树中的节点的结构是需要调整的，或先是往上改变父节点的关键字，再是往下，添加B树的层数，保持B树的平衡，性能相当于二分查找 B+树：基本相同，区别为：每个关键字都只用来索引，不存放数据；所有数据都保存在叶子结点中；为所有叶子结点存放一个链指针，链接所有的叶子结点；相比B树来说，更适合做文件索引系统，效率高的原因是减少了IO，减少了盘快读取的次数，减少了IO次数 B*树：就是在B+树的基础上，在非根非叶子结点间添加一个指向兄弟的指针，当节点满的时候，会直接移动到兄弟节点上去，空间利用率更高，分配新节点的概率较低，效率也有所提升 还没到我面试，总结一下并发的容器把并发系列的容器有ConcurrentHashMap CopyOnWriteArrayList 阻塞队列和非阻塞队列 1 1.8以前 采用segment数组和HashEntry 分段可重入锁的形式 保证 线程安全 通过分段锁的形式，降低了 ####]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[问题集]]></title>
    <url>%2F2019%2F09%2F07%2F%E9%97%AE%E9%A2%98%E9%9B%86%2F</url>
    <content type="text"><![CDATA[问题集 slice可以序列化后反序列化为原来的slice吗 /[]GameLoginTime 和 []/GmaeLoginTime 区别 Java 讲一下垃圾回收原理，垃圾回收器的过程 Java的闭包 hashMap的扰动函数 (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16) Java中各类型的HashCode是怎么生成的 String-for循环length次，31*h+value[i] Integer-hashCode就是他本身 Long-hashCode value^（value&gt;&gt;&gt;32） Character- 本身的ascii码 Golang Golang和Java有什么异同点 Golang和Java的闭包 基本数据类型 Slice底层实现 channel底层实现 协程和线程的区别 因而下面我们来比较协程和线程。我们知道多个线程相对独立，有自己的上下文，切换受系统控制；而协程也相对独立，有自己的上下文，但是其切换由自己控制，由当前协程切换到其他协程由当前协程来控制。协程和线程区别：协程避免了无意义的调度，由此可以提高性能，但也因此，程序员必须自己承担调度的责任，同时，协程也失去了标准线程使用多CPU的能力。 Java和Golang的协程的实现 make和new的区别 闭包是啥咯 讲一下channel 通道 写一段goroutine通过channel实现同步的代码 讲一下Golang的垃圾回收机制 讲一下channel的close 计算机网络 NIO HTTP断点传输 TCP断点传输 Android Android是如何组织Activity的 前端 不可继承的CSS样式 杂七杂八 Cron的用法 Resful和RPC的区别 LRU实现 自我介绍面试官你好，我叫许炳鑫，来自广东财经大学的应届毕业生，专业是计算机科学与技术。主要学习的语言是Java和Golang。大三时有幸在一家互联网渠道运营公司做了三个月实习，岗位为服务端开发，从零开始，学习如何在Linux下，用Vim进行日常的Golang，参与公司相关平台的建设与项目的开发，接触了一些在实际业务开发中才会有的业务场景，从而将自己平时所学与实际开发融会贯通。我实习时选择的是Golang实习而不是Java实习的原因是，我本身有意向去让自己学更多的东西，提升自己的广度，当然我们提升广度的同时，也需要保证一定的深度。听昨天的贵公司的宣讲会，非常想进贵公司。我的介绍结束。]]></content>
      <categories>
        <category>notFinished</category>
      </categories>
      <tags>
        <tag>notFinished</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识体系串讲3-继承]]></title>
    <url>%2F2019%2F09%2F04%2FJava%2FJava%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E4%B8%B2%E8%AE%B23-%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[继承是java面向对象编程技术的一块基石，因为它允许创建分等级层次的类。继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。 关键字extends表明正在构造的新类派生于一个已存在的类。 已存在的类称为超类、基类或父类，新类称为子类、派生类或者孩子类 super的用法code 12super.getSalary() // 调用方法super(n, s, year, month, day) // 调用构造方法 当子类没有显式调用父类构造器时 自动地调用超类（默认没有参数） 如果超类没有不带参数的构造器，Java编译器将报告错误 Java中使用super调用超类的方法，而在C++中则采用超类名加上::操作符的形式。例如，在Manager类的getSalary方法中，应该将super.getSalary替换为Employee::getSalary 由一个公共超类派生出来的所有类的集合被称为继承层次，从某个特定的类到其祖先的路径被称为该类的继承链 Java不支持多继承 多态 多态是同一个行为具有多的不同表现形式或形态的能力 多态就是同一个接口，使用不同的实例而执行不同操作 在此处讲一下C++中的虚函数 C++的多态是通过虚函数来实现的，在C++中，方法被virtual修饰的话，该方法为虚函数，可以被子类覆盖 纯虚函数在基类中没有定义，但要求任何派生类都要定义实现自己的方法，在基类中实现纯虚函数的方法是在函数原型后加“=0” 类中至少有一个函数被声明为纯虚函数，则这个类就是抽象类，所以一个抽象类是可以有纯虚函数与虚函数与非虚函数的 如果子类没有重写纯虚函数，就尝试实例化该函数的话，会导致编译错误 下面的代码是通过地址来调用方法的，没接触过的，耐心点看，也看得懂的啦 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;using namespace std; class A &#123;public: virtual void vfunc1() &#123; cout &lt;&lt; "A::vfunc1()" &lt;&lt; endl; &#125;; virtual void vfunc2() &#123; cout &lt;&lt; "A::vfunc2()" &lt;&lt; endl; &#125;; void func1() &#123; cout &lt;&lt; "A::func1()" &lt;&lt; endl; &#125;; void func2() &#123; cout &lt;&lt; "A::func2()" &lt;&lt; endl; &#125;;private: int data1_; int data2_;&#125;; class B :public A &#123;public: virtual void vfunc1() override &#123; cout &lt;&lt; "B::vfunc1()" &lt;&lt; endl; &#125;; void func2() &#123; cout &lt;&lt; "B::func2()" &lt;&lt; endl; &#125;;private: int data3_;&#125;; class C :public B &#123;public: virtual void vfunc1() override &#123; cout &lt;&lt; "C::vfunc1()" &lt;&lt; endl; &#125;; void func2() &#123; cout &lt;&lt; "C::func2()" &lt;&lt; endl; &#125;;private: int data1_, data4_;&#125;; //演示了手动调用虚函数的过程int main() &#123; B a; typedef void(*Fun)(void); Fun pFun = nullptr; cout &lt;&lt; "虚函数表地址：" &lt;&lt; (int*)(&amp;a) &lt;&lt; endl; cout &lt;&lt; "虚函数表第1个函数地址："&lt;&lt;(int*)*(int*)(&amp;a) &lt;&lt; endl; cout &lt;&lt; "虚函数表第2个函数地址：" &lt;&lt; (int*)*(int*)(&amp;a) + 1 &lt;&lt; endl; pFun = (Fun)*((int*)*(int*)(&amp;a)); pFun(); pFun = (Fun)*((int*)*(int*)(&amp;a) + 1); pFun(); return 0;&#125;————————————————版权声明：本文为CSDN博主「i_chaoren」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/i_chaoren/article/details/77281785 所以，其实，Java中不存在虚函数（压根没有virtual修饰符），但其实在方法中已经默认用了虚函数这个概念，所以不需要修饰符，即可通过@Override实现重写，直接撰写重载后的同名构造方法，直接通过父类实现不同的接口，得到不同的对象 所以，多态的概念派生出了了覆盖（重载和重写）和重载（同名函数） 但其实说来说去，有了继承才有多态，所以说继承和多态可以说成一个概念，也不是不行 所以，面向对象的基本特征就是两个：封装和继承（继承包括多态），你也可以说三个：封装、继承和多态 为什么我会有这个疑问呢，附上链接https://blog.csdn.net/baidu_33714003/article/details/52290627 虚拟机中的方法的动态绑定 emmm 暂时不写 留着 留个坑 final类和final方法 阻止继承，若希望阻止某类定义子类，则使用final修饰符声明 1public final class Executive extends Manager - final类下的所有方法自动地变成了final方法，final修饰的方法无法被覆盖（重载或重写） 父子类的强制类型转换 只能在继承层次内进行类型转换 在将超类转换成子类之前，应该使用instanceof进行检查 123if (staff[1] instanceof Manager) &#123; boss = (Manager) staff[1]&#125; - Instanceof运算符是用来运行时指出对象是否是特定类的一个实例 1result = object instanceof class - 如果要进行强制类型转换，一般说明你的父类设计的有问题 抽象类 被abstract修饰的方法叫抽象方法，抽象方法不需要被实现 包含一个或多个抽象方法的类本身必须被声明为抽象的，称为抽象类 Java中的抽象类与C++中的抽象类一样，都允许包含具体数据与具体方法 抽象方法充当着占位的角色 扩展抽象类有两种选择 在抽象类 中定义部分抽象类方法或不定义抽象类方法，这种情况下，子类也需标记为抽象类 在抽象类中定义全部的抽象方法，这种情况下，子类就不需要是抽象的了 类即使不含抽象方法，也可以将类声明为抽象类 抽象类不能被实例化，但是可以被定义 1Person p = new Student("hhha"); // Person是抽象类，Student是Person的子类 Object类：所有类的超类 可以使用Object类型的变量引用任何类型的对象： 1Object obj = new Employee("Harry Hacker", 35000); - 在Java中，只有基本数据类型不是对象 equals方法 用于检测一个对象与另一个对象是否具有相同的引用 Java语言规范要求equals方法具有下面的特性： 自反性：对于任何非空引用x，x.equals(x)应返回true 对称性：对于任何引用x和y，当且仅当y.equals(x)返回true，x.equals(y)也应该返回true 传递性：对于任何引用x、y和z，如果x.equals(y)返回true，y.equals(z)返回true，x.equals(z)也应该返回true 一致性：如果x和y引用的对象没有发生变化，反复调用x.equals(y)应该返回同样的结果 对于任意非空引用x，x.equals(null)应该返回false hashCode方法 若重新定义了equals方法，就必须重新定义hashCode方法，以便用户可以将对象插入到散列表中 如果x.equals(y)返回true，那么x.hashCode()就必须等于y.hashCode()具有相同的值，需要根据equals的定义来定义hashCode方法 toString方法 用于返回表示对象值的字符串 泛型数组列表 Java中，允许在运行时确定数组的大小 12int actualSize = . . .;Employee[] staff = new Employee[actualSizxe]; 当然，这段代码并没有完全解决运行时动态更改数组的问题。一旦首次确定了数组的大小，就没那么容易改变数组的大小了，是一种假动态 要用就用ArrayList 类型化与原始数组列表的兼容性 jdk5之前，还没有泛型，存在着原始遗留代码 下面看一些没有使用类型参数的代码 123456public class EmployeeDB&#123; public void update(ArrayList list) &#123;. . .&#125; // ArrayList没有指定类型参数 public ArrayList find(String query) &#123;. . .&#125; // 同上&#125;ArrayList&lt;Employee&gt; staff = . . .;employeeDB.update(staff); // 这样子是不会报错的 尽管编译器不会报错，但如果添加进去的数组元素不是Employee类型，这就麻烦咯 相反地，将一个原始的ArrayList赋给一个类型化ArrayList会得到一个警告 1ArrayList&lt;Employee&gt; result = employeeDB.find(query); // yields warning 使用类型转换的时候，避免不了警告 一旦能确保不会造成严重的后果，可以使用@SuperessWarnings(“unchecked”)标注来标记这个变量能够接受类型转换 对象包装器与自动装箱 所有的基本类型都有一个与之对应的类，这些类称为包装器 int与Integer会自动变换，这种变换称为自动装箱与自动拆箱 参数可变的方法 1public PrintStream printf(String fmt, Object... args) …表明这份方法可以接受任意数量的对象，用数组的方式访问 反射 反射库提供了一个非常丰富且精心设计的工具集，以便编写能够动态操纵java代码的程序 能够分析类能力的程序称为反射，反射机制可以用来： 在运行时分析类的能力 在运行时查看对象，例如，编写一个toString方法供所有使用 实现通用的数组操作代码 利用Method对象，这个 对象很像C++中的函数指针 Class类 Java运行时，系统始终为所有的对象维护一个被称为运行时的类型标识，这个信息跟踪着每个对象所属的类。虚拟机利用运行时类型信息选择相应的方法执行。 保存这些信息的类被称为Class，Object类中的getClass()方法将会返回一个Class类型的实例 Class对象实际上表示的是一种类型，而这个类型未必一定是一种类。例如，int不是类，int.class是一个Class类型的对象 可以利用==运算符实现两个类对象比较操作 捕获异常 异常分为：未检查异常和已检查异常 对于已检查代码，编译器将会检查是否提供了处理器。try catch就是常见的捕获异常 未检查代码，编译器会直接抛出异常，例如null引用，是属于未检查异常 所有异常若未处理，编译器就会给出错误报告]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识体系串讲2-对象与类]]></title>
    <url>%2F2019%2F09%2F02%2FJava%2FJava%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E4%B8%B2%E8%AE%B22-%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[对象：对象是类的一个实例（对象不是找个女朋友），有状态和行为。例如，一条狗是一个对象，它的状态有：颜色、名字、品种；行为有：摇尾巴、叫、吃等。类：类是一个模板，它描述一类对象的行为和状态。 面向对象 一个类应该有 实例域 私有的数据域 公有的域访问器和域更改器 getter 和 setter 构造方法 toString()方法 隐式参数和显式参数 Number007.raiseSalary(5) 出现在方法名前的是隐式参数 number007 出现在方法名后面括号中的数值是显式参数 5 一个方法可以访问所属类的所有对象的私有数据 final实例域 一个构造器执行之后，这个域的值被设置，并且在后面的操作中，不能够再对它的值进行修改 1private final String name; final关键字若修饰对象的话，只是表示存储在evaluations变量中的对象引用不会再指示其他StringBuilder对象，但是对象是可以修改的 1234private final StringBuilder evaluations = new StringBuilder();public void giveGoldStar()&#123; evaluations.append(LocalDate.now(): ":Gold star!\n");&#125; static域与static方法 静态域 每个类只有一个这样的域，而每个对象对于所有的实例域却都有自己的一份拷贝，这个类的所有实例将共享一个nextId域 123class xxx&#123; private static int nextId = 1;&#125; 它只属于类，不属于任何独立的对象 静态常量 1public static final double PI = 3.1415...... 可以采用Math.PI获得 静态方法 1Math.pow(x, a) // x的a次方 没有隐式参数，只有显式参数 静态方法是一种不能向对象实施操作的方法 在下面两种情况下使用静态方法 一个方法不需要访问对象状态，其所需参数都是通过显式参数提供 Math.pow(x, a) 一个方法只需访问类的静态域 Employee.getNextId() 工厂方法 使用工厂方法来构造对象 为什么不利用构造器来完成这些操作呢？ 无法命名构造器，所有的构造器只有参数不同，无法根据名字来选择所需要的对象 当好似哟给你构造器时，无法改变所构造的对象类型，构造器获得的对象永远都是初始，不能是继承的对象 方法参数 在程序设计语言中，方法接收参数传递的方式有两种 值调用 值传递 表示方法接受的是调用者提供的值 引用调用 引用传递 表示方法接收的是调用者传递的变量地址 名调用（已成为历史） Algol 最古老的程序设计语言之一 用的就是这种调用方式 Java总是按值调用 方法得到的是所有参数值的一个拷贝 方法不能修改传递给它的任何参数变量的内容 而对象引用作为参数就不同了 12345public static void tripleSalary(Employee x)&#123; // works x.raiseSalary(200);&#125;harry = new Employee(. . .);tripleSalary(harry); x被初始化为harry值的拷贝，这里是一个对象的引用 raiseSalary方法应用于这个对象引用，x和harry同时引用的那个Employee对象的薪金提高了200% 方法结束后，参数变量x不再使用。当然，对象变量harry继续引用那个薪金增值3倍的雇员对象 Java中参数的使用情况 一个方法不能修改一个基本数据类型的参数 一个方法可以改变一个对象参数的状态 一个方法不能让对象参数引用一个新的对象 突然想到一个问题 我们要如何主动回收对象 在Java里面 emmm 我为什么会想到这呢 我也不知道 emmm 搜索另一篇文章 辣鸡回收 GC finalize 方法小结 重载 有些类有多个构造器，有相同的名字和不同的参数，便产生了重载 如果在构造器中没有显式地给域赋予初值，那么就会自动地赋予默认值：0、false或者null 这样子会影响代码的可读性 无参数的构造器 编写一个类时没有编写构造器，那么系统就会提供一个无参数构造器，这个构造器将所有的实例域设置为默认值 如果类中提供了至少一个构造器，但是没有提供无参数的构造器，则在构造对象时如果没有提供参数就会被视为不合法 一种另类的构造器 12345public Employee(double s) &#123; // calls Employee(String, double); this("Employee #" + nextId, s) nextID ++;&#125; 初始化快 123456789101112131415class Employee &#123; private static int nextId; private int id; private String name; private double salary; // object initialization block &#123; id = nextId; nextId ++; &#125; public Employee(String n, double s) &#123; name = n; salary = s; &#125;&#125; 无论使用哪个构造器构造对象，id域都在对象初始化块中被初始化 对象析构与finalize方法 C++有显式的析构器方法，其中放置一些当对象不再使用时需要执行的清理代码，在析构器中，最常见的操作时回收分配给对象的存储空间 由于Java有自动的垃圾回收器，固Java不支持析构器 可以为任何一个类添加finalize方法，将在垃圾回收器清理对象之前调用。在实际应用中，不要依赖于使用finalize方法回收任何短缺的资源，这是因为很难知道这个方法什么时候才能调用 如果某个资源需要在使用完毕后立刻关闭，那么就需要由人工来管理。对象用完时，可以应用一个close方法完成相应的清理操作 类的导入 每个类名之前添加完整的包名 使用import语句，无需添加包前缀 静态导入 import static 无需添加 类名前缀 Java成员变量的作用域 作用域 当前类 同一package 子类 其他package public 可见 可见 可见 可见 protected 可见 可见 可见 不可见 default 可见 可见 不可见 不可见 private 可见 不可见 不可见 不可见]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[垃圾回收GC finalize方法 小结]]></title>
    <url>%2F2019%2F08%2F29%2FJava%2F%E8%BE%A3%E9%B8%A1%E5%9B%9E%E6%94%B6%20GC%20finallize%20%E6%96%B9%E6%B3%95%E5%B0%8F%E7%BB%93%20%2F</url>
    <content type="text"><![CDATA[垃圾回收GC finalize方法 小结 這是屬於 java.lang.Object 上的一個 method, 其設計目的是保證物件在被 GC 之前完成特定資源的回收作業. 不過由於這東西真的太不穩定了, 所以從 JDK 9 開始已經被標成 deprecated 了. 至於這個…, 就把它當作時代的眼淚吧. 這在業界裡基本上是一再證明不是個好方案了, 所以在 JDK 9 中已經被標註為 deprecated 了. 除非你有特殊原因, 不然不要去實作這個方法, 也不要期待透過這個方法來進行 GC. 原因很簡單: 因為你沒有辦法確保 finalize 的執行時間. 就算執行了, 也不確定是否能符合預期 (這要扯到 JVM 的 GC 機制, 這邊沒地方寫了). 使用不當還會影響性能, 進而導致 dead lock, hanging 等問題. 手动垃圾回收的三种方式 其实小标题是一种误导，这根本不是三种方式，因为我们可以做的只是通过手动的形式 增加一些机会 执行一些内存清理释放的方法 的机会 将对象设为null，GC会优先回收 String xx = null; finallize方法，GC在回收对象之前调用该方法，你可以重写此方法来增加一些close和什么鬼的方法，统一资源清理（已经不推荐了） System.gc 会添加GC的机会，其实这个gc()函数的作用只是提醒虚拟机：程序员希望进行一次垃圾回收。但是它不能保证垃圾回收一定会进行，而且具体什么时候进行是取决于具体的虚拟机的，不同的虚拟机有不同的对策。 finalize()是Object的protected方法，子类可以覆盖该方法以实现资源清理工作，GC在回收对象之前调用该方法。 finalize()与C++中的析构函数不是对应的。C++中的析构函数调用的时机是确定的（对象离开作用域或delete掉），但Java中的finalize的调用具有不确定性 不建议用finalize方法完成“非内存资源”的清理工作，但建议用于：① 清理本地对象(通过JNI创建的对象)；② 作为确保某些非内存资源(如Socket、文件等)释放的一个补充：在finalize方法中显式调用其他资源释放方法。其原因可见下文[finalize的问题] System.gc()与System.runFinalization()方法增加了finalize方法执行的机会，但不可盲目依赖它们 这东西 有点难讲清楚 我决定等我复习 虚拟机那本书 再来看看吧]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基础知识体系串讲1-基础知识]]></title>
    <url>%2F2019%2F08%2F29%2FJava%2FJava%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E4%B8%B2%E8%AE%B21-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%2F</url>
    <content type="text"><![CDATA[Java基础知识体系串讲1-基础知识知识层次分布 特性 简单性 Java没有头文件 指针运算 结构体 联合 操作符重载 等C++的特性 使用起来相对简单 面向对象 面向对象是一种程序设计技术，它将重点放在数据（即对象）和对象的接口上 与C++不同的点在于多重继承，Java取而代之的是接口概念 分布式（加粗为总结 非加粗为原文） 我的理解：为什么Java有分布式的特性： Java有丰富的库，用于处理TCP/IP协议，即可通过对应协议处理URL访问对应网络对象，从而可以建立起一条网络对象与网络对象之间沟通的渠道，从而实现分布式通信网络互联的多处理机体系结构上 Java有丰富的库，用于处理像HTTP和FTP之类的TCP/IP协议 Java应用程序能够通过URL打开和访问网络上的对象，极其便携 分布式软件系统是支持分布式处理的软件系统，是在由通信网络互联的多处理机体系结构上执行任务的系统。它包括分布式操作系统、分布式程序设计语言及其编译（解释）系统、分布式文件系统和分布式数据库系统等 健壮性 Java编译器能够检测许多在其他语言仅在运行时才能够检测出来的问题 Java采取的指针模型消除了重写内存和损坏数据的可能性 Java投入了大量的精力进行了早期的问题检测、后期动态的（运行时）的检测 安全性 Java能够防范各种攻击 运行时堆栈的溢出。如蠕虫和病毒常用的攻击手段 破坏自己的进程空间之外的内存 未经授权读写文件 体系结构中立 编译器生成一个体系结构中立的目标文件格式，这是一种编译过的代码，称为字节码 Java编译器通过生成与特定的计算机体系结构无关的字节码指令来实现这一特性 精心设计的字节码可以在任何机器上解释运行 实际运行的环境为机器上的虚拟机 解释虚拟机指令肯定会比全速运行机器指令药慢很多 虚拟机也可以将执行最频繁的字节码序列翻译成机器吗，这一过程称为即时编译 可移植性 Java由于上述虚拟机的存在，所有的数据类型都有固定的大小 二进制数据以固定的格式进行存储和传输，消除了字节顺序的困扰 字符串是以表转的unicode格式存储的 Java语言编译程序只需将编译生成在Java虚拟机运行的字节码，Java虚拟机在执行字节码时，把字节码解释成目标平台的机器吗，进行执行，“一次编译，到处运行” 解释型 Java解释器可以在任何移植了解释器的机器上执行Java字节码 高性能 多线程 针对多线程有自己的一套库的处理机制 动态性 基本数据类型（不包括引用数据类型） 整形 int 4byte -20亿～20亿（大于20亿） -2^31~2^31-1 short 2byte -32768～32767 -2^15~2^15-1 long 8byte -2^63~2^63-1 Byte 1byte -2^7~-2^7-1 进制前缀 二进制 0b 八进制 0 十六进制 0x 例如0xCAFE（魔数） 浮点型 float 4byte double 8byte 默认为double float后面有后缀F或f 没有后缀F默认为double 原因是float类型的精度很难满足需求 存在三种特殊的浮点数值 正无穷大 Double.POSITIVE_INFINITY 负无穷大 Double.NEGATIVE_INFINITY NaN（is not number）Douboe.NaN 判断是否是一个数值 Double.isNaN(x) Unicode和char类型 2字节 16位 Unicode-16 boolean类型 两个字节 与short同等大小 2byte 16位 变量与对象 变量一定要初始化，初始化为对应的值，无默认 常量 关键字final表示这个变量只能被赋值一次。一旦被赋值之后，就不能再更改 习惯上，常量名使用全大写 使用static final来定义一个类常量 普通常量定义在方法的内部，仅供方法使用 类常量定义在方法外部，可供一个类中的多个方法使用 0 整数被除0将会产生一个异常，而浮点数被0除将会得到无穷大或者NaN的结果 123public static final double NaN = 0.0d / 0.0;public static final double POSITIVE_INFINITY = 1.0 / 0.0;public static final double NEGATIVE_INFINITY = -1.0 / 0.0; emmm Java中浮点数除以0 是无穷大 记住吧 比较特殊 Math方法 Math方法是可以直接调用的，无须import import static java.lang.Math.*; 此为静态导入 静态导入后 调用方法时，无需添加前缀Math 常用方法 max min pow sqrt Random 此处贴上一份关于Random的研究 随机数也可以使用Random类来实现 是伪随机数 https://blog.csdn.net/qq_33101675/article/details/81028210 round 四舍五入 强制类型转换 注意精度 int转换为float long转换为float long转换为double 都可能损失精度 自增自减运算符 前缀形式的 会先完成加一 再使用加一后的新变量 ++i 后缀形式的 会先使用旧变量 再完成加一 i++ 位运算符 &amp; and | or ^ xor(异或) ~ nor(同或) &lt;&lt; 位模式左移 逻辑左移 右边补0 >&gt; 位模式右移 逻辑右移 左边补符号位 >&gt;&gt; 无符号位模式右移 无符号右移 左边补0 优先级 括号优先 判断优先 其次运算 最后赋值 枚举类型 变量的取值只在一个有限的集合内，若直接存放在变量中，可能会保存为错误的值 可自定义枚举类型，枚举类型包括有限个命名的值 12enum Size&#123;SMALL, MEDIUM, LARGE, EXTRA_LARGE&#125;Size s = Size.MEDIUM; Size类型的变量只能存储这个类型声明中给定的某个枚举值，或者null，null表示这个变量没有设置任何值 String 概念上讲，Java字符串就是Unicode字符序列 Java标准类库中提供了String的预定义类，每个双引号扩起来的字符串都是String类的一个实例 《深入理解Java虚拟机》中写到，String是存放在常量池中的 严谨点的话，String并不是Java中的基本数据类型，是属于引用数据类型，上面讲的其实都是基本数据类型 获取子串 12String greeting = "Hello";String s = greeting.substring(0, 3); 得到“Hel”子串，首参数为开始的位置，次参数为结束的位置（不包括结束位置本身） 拼接字符串 用+号拼接 int也可以参与拼接 1234int a = 123;int b = 456;String s = a + "" + b; // 输出 123456String ss = a + b + ""; // 输出 579 字符串在Java中是不可变的，需要变化字符串靠拆分与拼接 不可变的好处 编辑器可以让字符串共享 从jdk6及以前，String常量池存放在方法区中的运行时常量池中，方法区位于永久代 jdk7，String常量池转移到堆中 Jdk8，永久代被取消，新增MetaSpace 1// TODO 虚拟机也得好好复习一遍了 好多东西讲的不是很清楚 串不起来 String.intern() intern()方法设计的初衷，就是重用String对象，以节省内存消耗 使用intern()方法，运行时间增长，这是因为，虚拟机会先new String后再intern指向常量池中的引用 1234567 String s = new String("1"); //常量池中添加“1”，生成堆对象s，返回指向堆中s的引用 String intern = s.intern(); //常量池中已有“1”，返回常量池中“1”的引用 String s2 = "1"; //常量池中已有“1”，返回常量池中“1”的引用System.out.println(s2 == intern);//true 两者返回的都是常量池中“1”的引用 System.out.println(s == intern);//false 堆引用地址和常量池引用地址不相等 原文链接：https://blog.csdn.net/hz90s/article/details/80819619 - 实验证明，如引用常量池中的String，会有限返回intern生成的新的堆引用地址的String String.equal() 比较字符串的内容是否相等 如果用等号==来比较，会比较位置是否相等，而不是比较内容是否相等 空串和null 空串即长度为0或者内容为空 1String = ""; null即表示目前没有任何对象与该变量关联 1if(str == null) // probably appear error 码点与代码单元 emmm 这是个我认为比较偏的概念 core 卷1上讲的云里雾里的 如果你求知欲很强的话 就看下去 我会用比较接地气的方式解释这个名词 个人认为 不了解 只是少个知识点而已 影响不大 可不看 但是 谁叫我 什么东西都想知道全面一点呢 没办法 还是吃掉这个知识点吧 先讲两个名词解释 码点：就是某个任意字符在Unicode编码表中对应的代码值 代码单元：是在计算机中用来表示码点的，大部分码点只需要一个代码单元表示，但是有一些是需要两个代码单元来表示的 上面讲到 我们的char采用utf-16编码表示unicode字符 占两个字节 16位 故utf-16的代码单元占2个字节 如果是utf-8的话 就占1个字节 大多数的常用的Unicode字符使用两个字节就能表示 但是 实际上 两个字节 16位 也不够用了 已经出现一些字符 超过两个字节 就比如 U+1D546 长这样 𝕆 要两个代码单元 为了对比明显 列举一个只要一个代码单元的 U+0022 长这样 “ 就是我们的双引号啦 不要使用char放 放不下啊兄弟 StringAPI (括号中的括号为可选的意思) char charAt(int index) boolean equal(Object other) boolean startsWith(String prefix) boolean endsWith(String suffix) 如果字符串以prefix 或者 suffxi 开头或结尾 返回true int indexOf(String str (int fromIndex)) int indexOf(int cp (int fromIndex)) 返回子串或者字符的位置 从fromIndex开始（可选） length() 整个Java中 只有String有length() 加括号 而数组长度为 length 其他什么找长度的 都是size String substring(int beginIndex, (int endIndex)) String toLowerCase() String toUpperCase() String trim() — 修 剪 删除字符串头部和尾部的空格 String join(CharSequence delimiter, CharSequence … elements) 看不懂？ 给你个样例 12345678String[] arrStr=new String[]&#123;"a","b","c"&#125;;System.out.println(String.join("-", arrStr));输出：1-2-3a-b-c String replace（CharSequence oldString, CharSequence newString） StringBuilderAPI int length() StringBUilder append(String str) StringBuilder append(char c) StringBuilder appendCodePoint(int codepoint) 追加一个码点，并将其转换为一个或两个代码大院并返回this void setCharAt(int i, char c) 将第i个代码单元设置为c StringBuilder insert(int offset, String str / Char c) StringBuilder delete(int startIndex, int endIndex) delete startIndex ~ endIndex-1 toString() 输入输出(两种方式) Scanner in = new Scanner(System.in); String in.nextLine() 下一行 String in.next(); 下一个单词 int in.nextInt(); double in.nextDouble(); boolean in.hasNext(); boolean in.hasNextInt(); boolean in.hasNextDouble(); BufferReader buffer = new BufferedReader(new InputStreamReader(System.in)) buffer.readLine(); 格式化输出 System.out.printf(“%s”, s); d 十进制整数 x 十六进制整数 o 八进制整数 f 定点浮点数 e 指数浮点数 g 通用浮点数 a 十六进制浮点数 s 字符串 c 字符 b 布尔 h 散列码 tx or Tx 日期时间 % 百分号 （要输入百分号的时候 要打 %%） n 与平台的分隔符有关 windows相当于\n\r unix相当于\r Switch 这里提及switch语句是有私心的 因为 我只是想说一下 switch 在go里面 是默认带break的 哈哈哈 大数值 若基本的整数和浮点数精度不能够满足需求，java.math有两个很有用的类 BigInteger and BigDecimal （我竟然不知道decimal是小数的意思） 前者实现了任意精度的整数运算，后者实现了任意精度的浮点数运算 数组 爱怎么初始化怎么初始化 int[] a int a[] int [] a = new int[100] 不规则数组 Java实际上没有多维数组，只有一维数组。多维数组被解释为“数组的数组” Java中的泛型Java泛型是在Jdk1.5中引入的新特性，其元素的种类是多种多样的，可以是任意类型，作为参数对象，传入函数中]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统与Linux综合学习]]></title>
    <url>%2F2019%2F08%2F27%2FLinux%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%8ELinux%E7%BB%BC%E5%90%88%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[内核内核 Kernel 是一个用来管理软件发出的数据I/O要求的计算机程序，将这些要求转译为数据处理的指令并交由中央处理器（CPU）及计算机中其他电子组件进行处理，是现在操作系统中最基本的部分。本来计算机中的应用程序是可以直接地调入计算机中执行的，但是直接对硬件进行操作是非常复杂的。所以内核通常提供一种硬件抽象的方法，来完成这些操作，所以从某种程度上来说，内核也不是必要的组成部分。 简而言之，内核控制计算机资源，提供程序的运行环境 内核分类分为宏内核和微内核两大架构，宏内核与微内核之间，还有一种混合内核；微内核之下还有一种极端的设计方式，成为外内核 宏内核宏内核结构在硬件的基础上，定义了一个高阶的抽象接口，应用一组原语（或者叫系统调用system call）来实现操作系统的功能，例如进程管理，文件系统和存储管理等等，这些功能由多个运行在内核态的模块来完成。 尽管每一个模块都是单独地服务这些操作，内核代码是高度集成的，一个宏内核相当于是一个二进制的大应用程序，模块间的通讯是通过直接调用其他模块中的函数实现的，而不是通过消息传递，系统服务的实现以及系统的基本操作规则是耦合的。因此一个使某模块功能瘫痪的bug会使整个系统需要崩溃重启 然而，如果开发顺利，单内核结构就可以从运行效率上得到好处 常见的宏内核有Linux和Unix 微内核微内核结构是由一个非常简单的硬件抽象和一组比较关键的原语或系统调用组成；这些原语，仅仅包括了创建一个系统必须的几个部分；如线程管理、地址空间和行程间通讯（进程或线程） 微内核的目标是将系统服务的实现和系统的基本操作规则分离开来。一个服务组件的失效并不会导致整个系统的崩溃，内核需要做的，仅仅是重启这个组件，而不影响其他部分。 然而，微内核相比单内核可能有一点运行效率上的差别，在调用模块的时候，宏内核是采用的是方法间的调用，微内核采用的是组件的调用 微内核经常被用于机器人和医疗器械的嵌入式设计中 宏内核和微内核的共同点，就是他们都有创建一个系统的必要组成部分：线程管理、地址空间和行程间通讯 混合内核混合内核的设计理念来自微内核，只不过它让一些微核结构运行在用户空间的代码运行在内核空间，让内核的运行效率更高 外内核外内核系统，也被称为纵向结构操作系统，是一种比较极端的设计方法 它的设计理念是让用户程序的设计者来决定硬件接口的设计。外内核本身非常的小，它通常只负责系统保护和系统资源复用相关的服务 传统的内核设计都对硬件作了抽象，把硬件资源或设备驱动程序都隐藏在硬件抽象层下。比方说，在这些系统中，如果分配一段物理存储，应用程序并不知道它的实际位置。 而外核的目标就是让应用程序直接请求一块特定的物理孔家你、一块待定的磁盘块等等。系统本身只保证被请求的资源当前是空闲的，应用程序就允许直接访问它。既然外核系统只提供了比较低级的硬件操作，而没有像其他系统一样提供高级的硬件抽象，那么就需要增加额外的运行库支持，这些运行库运行在外核之上，给用户程序提供了完成的功能。 理论上，这种设计可以让各种操作系统运行在一个外核之上，如Windows和Unix。并且设计人员可以根据运行效率调整系统的各部分功能。 现在，外核设计还停留在研究阶段，没有任何一个商业系统采用了这种设计。几种概念上的操作系统正在被开发，如剑桥大学的Nemesis，格拉斯哥大学的Citrix系统和瑞士计算机科学院的一套系统。麻省理工学院也在进行着这类研究。PID简介 进程标识符 process identifier，简称进程ID process ID，PID，是大多数操作系统的内核用于唯一标识进程的一个数值。这一数值可以作为许多函数调用的参数，以使调整进程优先级、杀死进程之类的进程控制行为成为可能 Pstree 命令pstree命令是用于查看进程树之间的关系，即哪个进程是父进程，哪个进程是子进程，可以清楚的看出进程与进程之间的关系 几个重要的参数： -A：各进程树之间的连接以ASCII码字符来连接 -U：各进程树之间的连接以UTF8码字符来链接 -p：同时列出每个进程的PID -u：同时列出每个进程的所属账号名称 Supervisor学习简介Supervisor是基于Python开发的一个client/server服务，是Linux/Unix系统下的一个进程管理工具，不支持Windows系统，可以很方便的监听、启动、停止、重启一个或多个进程。此外，若有进程无法在其运行崩溃之后自行重新启动，Supervisor将会重新启动 相关进程 作为 子进程，并自动的加载进程相关配置 supervisor安装完成后会生成三个执行程序：supervisortd、supervisorctl、echo_supervisord_conf，分别是supervisor的守护进程服务（用于接收进程管理命令）、客户端（用于和守护进程通信，发送管理进程的指令）、生成初始配置文件程序。 相关blog与官方文档 https://blog.csdn.net/xyang81/article/details/51555473 http://supervisord.org/introduction.html K8S Docker LISP ipvs]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[笔记]]></title>
    <url>%2F2019%2F07%2F29%2F%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[问题集 restful orm 面向接口编程 等多种编程过程的区别 maven的整体结构 classpath是哪里]]></content>
  </entry>
  <entry>
    <title><![CDATA[近期需要整理的各种知识体系]]></title>
    <url>%2F2019%2F07%2F24%2F%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%2F%E8%BF%91%E6%9C%9F%E9%9C%80%E8%A6%81%E6%95%B4%E7%90%86%E7%9A%84%E5%90%84%E7%A7%8D%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%2F</url>
    <content type="text"><![CDATA[哎 自从实习开始 知识体系就没有成立过 知道的东西的确很多 但是没有串在一起 非常容易忘 我必须要 狠下心来 整理一次 关于Linux的知识路线 Linux起源 版本 区别 一些历史性的东西 CentOS Linux的基本操作命令 例如 管道命令 grep命令 安装命令yum 修改权限命令chmod 查看各种东西 又比如输出日志 还有什么 从明天开始 边使用 边整理 还有vim 等 Linux整个系统的文件结构 文件系统 是怎么分配的 怎么形成的 磁盘分区 等 Linux的网络编程 以及其他编程等等 Go 看基础知识 看书 Go的特色 有什么 Go的Web开发 Go的高并发 Go的源码 RPC框架 Thrift 与Dubbo 使用与区别 参数都是有什么用的 服务中心 Zookeeper和etcd的区别 与使用 参数有什么用 消息队列 卡夫卡和RabbitMQ的区别与使用 还没开始学习呢 数据库 各种读写分离的 本质 数据库的相关优化 那些参数都有什么用 Redis缓存 各种读写分离的本质 以及相关优化 并且还有使用 那些参数都有什么用 实习 实习的过程中 学习到了什么 实习的项目经历 实习遇到的难题 实习的感受 Java Java的基础 Java的多线程 Java的虚拟机 Java的网络开发框架 Java的源码 Java的学习成本是真的高 我现在啥都学的不是很精啊 完了 php 这门脚本语言的学习 还是有帮助的 php的学习放到最后把 有机会再学习把 操作系统 暂时不知道呀 问题1]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>学习日记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Thrift学习笔记]]></title>
    <url>%2F2019%2F07%2F10%2FRPC%2FThrift%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"></content>
      <categories>
        <category>RPC</category>
      </categories>
      <tags>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XML和JSON和序列化的区别]]></title>
    <url>%2F2019%2F07%2F10%2F%E5%89%8D%E7%AB%AF%2FXML%E5%92%8CJSON%E5%92%8C%E5%BA%8F%E5%88%97%E5%8C%96%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[什么是 XML? XML 指可扩展标记语言（EXtensible Markup Language） XML 是一种标记语言，很类似 HTML XML 的设计宗旨是传输数据，而非显示数据 XML 标签没有被预定义。您需要自行定义标签。 XML 被设计为具有自我描述性。 XML 是 W3C 的推荐标准 XML 与 HTML 的主要差异 XML 不是 HTML 的替代。 XML 和 HTML 为不同的目的而设计： XML 被设计为传输和存储数据，其焦点是数据的内容。 HTML 被设计用来显示数据，其焦点是数据的外观。 HTML 旨在显示信息，而 XML 旨在传输信息。 没有任何行为的 XMLXML 是不作为的。 也许这有点难以理解，但是 XML 不会做任何事情。XML 被设计用来结构化、存储以及传输信息。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[XML解析工具]]></title>
    <url>%2F2019%2F07%2F10%2F%E5%89%8D%E7%AB%AF%2FXML%E8%A7%A3%E6%9E%90%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[DOM解释器SAX解释器JDOM解释器DOM4J解释器]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[本地虚拟机连接XSHELL或SecureCRT]]></title>
    <url>%2F2019%2F05%2F19%2FLinux%2F%E6%9C%AC%E5%9C%B0%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BF%9E%E6%8E%A5XSHELL%E6%88%96SecureCRT%2F</url>
    <content type="text"><![CDATA[用VMware Workstation装的虚拟机, 具体安装过程请自行百度啦, 搜索关键字CentOS对应版本的安装 就出来啦. 来公司的第一件事, 老大叫我配个Go环境的虚拟机, 虚拟机的安装倒是跟着教程一步步的弄好了, 想要用SecureCRT连接本地虚拟机, 总不能用VMware Workstation自带的界面吧, 人家毕竟是专门做虚拟机的, 又不是专门做Shell工具的 常见的Shell工具有Xshell和SecureCRT两种啦, SecureCRT有自带的文件传输功能, XShell想要传文件可能需要另一个产品叫XFTP, XFTP的远程文件系统就比SecureCRT的功能要多一些了, 如果只是有上传文件和下载文件功能的需求 又不想装多一个东西的话, 用SecureCRT自带的sz和rz命令就可以啦, 如果需要在图形界面远程浏览虚拟机的文件系统, 就下XFTP吧 上面都是废话, 下面才是主要内容 虚拟机环境VMware Workstation 10 + CentOS 6.8 + Windows10 连接工具SecureCRT或者XShell 这里用的是SecureCRT 连接前提 虚拟机和远程终端工具 配置静态IP, 免得每次连接的时候都要查看IP, 如果没有设置静态IP的话, IP会随着你每次联网而不断变更的(下文会讲解如何配置静态IP) 虚拟机连接模式为NAT模式 如何配置虚拟机的静态IP 查看网卡IP名 cd /etc/sysconfig/network-scripts/ ifcfg-eth开头的就都是你的网卡IP名啦, 你可能有多个, 没关系, 挑一个来用就行了 编辑网卡文件 vim ifcfg-eth0 确认ONBOOT项为yes, 将IPADDR NETMASK GATEWAK DNS1改为对应项(见下文) 打开VMware Workstation 选择菜单 编辑-虚拟网络编辑器 如果信息框都是灰的, 没关系, 点击更改设置 赋予管理员权限 选择VMnet8 修改其子网 网段随意 子网掩码192的是24位 即 255.255.255.0 设置完后, 点击NAT设置, 修改网关入口, 修改完后确定 再次点击确定, 需要等一会, 因为他在修改你的网卡设置 按道理来说, 目前所有的步骤设置完之后, 是没有问题的, 保险起见, 我们去适配器设置看看VMnet8网卡配置是否正确 没问题之后, 将上面那个配置文件的IP 掩码和网关都配置好 dns配不配应该是没关系的 配置完后, 保存退出, 输入命令 service network restart 如果都是绿色的话 就没问题啦 如果有红色 配置肯定有问题的 可打ifconfig查看一下ip配置情况 有eth0的网卡配置就说明没问题啦 通过ifconfig获取的ip 地址 192.168.120.128(你有你的IP地址 自己查) 就可以用来远程连接了 打开SecureCRT或者XShell 建立新的连接 输入ip地址 并且输入用户名root或者你自己的用户名 连接成功 迁移了虚拟机 无法联网 怎么处理 在关闭虚拟机的情况下, 右键虚拟机-设置-网络适配器-高级 未关闭虚拟机的的情况下, 生成键是不可选的, 需关闭虚拟机才可以点击, 关闭后点击生成, 会生成mac地址 修改 ifcfg-eth0文件的HWADDR hardware地址 硬件地址即物理地址 修改为生成的mac地址 修改后, 重启网络 service network restart 应该是不行的, 会显示失败 重启虚拟机即可解决]]></content>
      <categories>
        <category>Linux</category>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.1 计算机网络的形成与发展]]></title>
    <url>%2F2019%2F05%2F19%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%2F1.1%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E5%BD%A2%E6%88%90%E4%B8%8E%E5%8F%91%E5%B1%95%2F</url>
    <content type="text"><![CDATA[最近想着复习一下计算机网络, 从计网的发展历史开始学起, 怎么说呢, 了解计算机网络的发展历史, 有助于我们加强对计算机网络的知识点的梳理, 让我们计算机网络这一块的知识的主干更加的稳固, 观察其每一步的发展, 你会发现, 其实每一步的改变都是有理有据的 PS: 这种过于理论的东西, 不想看的还是别看了哈哈, 不然很浪费时间和精力的, 付出和收获不成正比, 直接看下一部分吧 计算机网络发展阶段的划分经历了四个阶段: 计算机网络技术与理论准备阶段 数据通信技术奠定了技术基础 分组交换概念的提出奠定了理论基础 计算机网络的形成 ARPANET的成功运行证明了分组交换理论的正确性 TCP/IP协议的广泛应用为更大规模的网络互联奠定了坚实的基础 E-mail FTP TELNET BBS等应用展现出网络技术广阔的应用前景 网络体系结构的研究 开放系统互连(Open System Interconnection, OSI)参考模型的研究对网络理论体系的形成与发展, 以及在网络协议标准化研究方面起了重要的推动作用 TCP/IP经受了市场和用户的检验, 吸引了大量的投资, 推动了Internet应用的发展, 成为业界标准 Internet应用 无线网络与网络安全技术研究的发展 Internet作为全球性的国际网与大型信息系统, 在当今各个领域如政治 经济 社会生活等方面发挥了重要作用 Internet大规模介入推动了接入技术的发展, 促进三网融合 对等(Peer-to-Peer, P2P)网络技术的研究, 使得”即时通信“等新的网络应用不断涌现, 进一步丰富了人与人之间信息交互与共享 无线个人区域网 无线局域网与无线城域网技术日益成熟 Internet应用中数据采集与录入从人工方式逐步扩展到自动方式, 通过射频标签RFID 各种类型的传感器与传感器网络(Sence Network), 以及光学视频感知与摄录设备, 能够方便 自动地采集各种物品与环境信息, 拓宽了人与人 人与物 物与物之间更为广泛的信息交互, 促进了物联网(Internet of Things, IoT)技术的形成与发展 随着网络应用的快速增长, 社会对网络安全问题的重视程度也越来越高. 推动了网络安全技术的快速发展 计算机网络的形成与发展两个条件 强烈的社会需求 前期技术的成熟 ARPANET研究 针对部分网络设备或通信线路遭到破坏时, 网络系统仍能利用剩余的网络设备与通信线路继续工作, 称为“可生存系统”, 需要解决两个基本问题: 网络拓扑结构与数据传输方式 针对网络拓扑结构的问题 提出了集中式和非集中式的拓扑构型 集中式的星形网络中, 所有主机都与一个中心交换节点相连, 主机发送的数据都要通过中心节点转发. 如果中心节点受到破坏, 就会造成整个网络的瘫痪 非集中式网络采用的是星-星结构, 星形结构结构固有的缺点仍然难以避免 提出了分布式网络(distributed network)结构 分布式网络没有中心交换节点, 每个节点与相邻节点链接, 从而构成一个网状结构. 在网状结构中, 任意两点之间可以有多条传输路径, 如果网络中某个节点或线路损坏, 数据还可以通过其他的路径传输 这是一种具有高度容错性的网络拓扑结构 针对数据传输方式的问题 交换机的线路交换(circuit switching) 电话交换网 在用户通话之前, 需要通过交换机的线路交换, 在两部电话机之间建立线路连接 由于电话交换网是为人与人之间模拟的语音信号传输设计的, 如果直接利用电话交换网来传输计算机的数字数据信号存在两个主要的问题 通信线路的利用率很低, 造成资源浪费 误码率高, 计算机通信要求能准确传输每个比特, 故电话交换网直接用于计算机的数据传输是不适合的 分组交换技术(packet switching) 特征如下 网络中没有一个中心控制节点, 联网计算机独立的完成数据接收和转发的功能 发送数据的主机预先将待发送的数据 封装成多个短的 有固定格式的分组 如果发送主机与接受主机之间没有直接连接的通信线路, 那么就需要通过中间节点采用”存储转发“的方法转发分组, 这种中间转发节点就是目前广泛使用的路由器 每个路由器都可以独立地根据链路状态与分组的目的地址, 通过路由选择算法为每个分组选择合适的传输路径 当目的主机接收到属于一个报文的所有分组之后, 再将分组中多个数据字段组合起来, 还原成发送主机发送的报文. 构成分组交换技术的三个重要概念: 分组 路由选择 存储转发 最简单的路由选择算法是“热土豆法”, 当它接收到一个待转发的数据分组时, 它会尽快地寻找一个输出路径转发出去 好的路由选择算法应具有自适应能力, 应该能够发现网络中任何一个中间节点或一段链路出现故障时, 具有选择绕过故障的节点或链路来转发分组的能力 ARPANET设计思想 ARPANET要求连接不同型号的计算机, 必须满足”可生存网络”的要求, 保证数据传输的可靠性 ARPANET采取分组交换的思想, 将ARPANET分为两个部分 通信子网 通信子网的转发节点用小型计算机实现, 称为接口报文处理器(Interface Message Processors, IMP). IMP根据通信协议的规定将计算机发送的报文数据分成多个长度一定的数据块, 并封装成分组, 然后通过路由选择算法, 为每个分组选择输出路径, 然后将这些分组分别向下一个IMP发送. 下一个IMP在正确地接收到一个分组并存储之后, 向发送该分组地前一个IMP返回一个确认”ACK”分组, 再继续向下一个IMP转发. 如果出错, 则用”NAK”分组报告传输出错, 通知上一个IMP重传 就这样通过一个个IMP的接续, 直到分组正确地传输到目的主机为止 由源主机 发出的同一个报文的不同分组到达目的主机所经过的路径可能是不同的 在到达目的主机之前, 如果出现传输错误, 则丢失该传输, 并重复传输直到传输正确为止, 并且由于路径的不同, 可能出现传输乱序的现象 资源子网 用于资源传输 TCP/IP的研究与发展]]></content>
      <categories>
        <category>计算机网络</category>
        <category>1 计算机网络概论</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot秒杀项目(更新中……未完结)]]></title>
    <url>%2F2019%2F05%2F08%2F%E9%A1%B9%E7%9B%AE%2FSpringBoot%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[本文为关于练习Java项目写下的相关笔记，涉及到SpringBoot、Tomcat云端部署、线程池优化、分布式Nginx、分布式token扩展、缓存系列Redis、本地缓存、lua缓存、cdn优化、令牌与RocketMQ消息队列实现流量削峰、JMeter压力测试等知识体系，因为是练习项目，笔记内容可能比较混杂，我会遇到问题不断的延伸，所以才有了这么一份总结 两种archetype quickstart和webapp的区别archetype是骨架的意思，maven为我们开发制定好了一份项目的原始模版，我们可以在原始模版的基础上，进行扩展与延伸。 maven有提供各种各样的模版，这里只讲quickstart和webapp的区别 maven-archetype-quickstart maven-archetype-webapp maven配置路径如下，我用的是自带的maven3，仓库和配置文件的位置比较奇葩，请勿模仿，要放就放一个地方： 区别:项目结构不同quickstart的项目结构图 基本内容包括： 一个包含junit的依赖生命的pom.xml src/main/java主代码目录及一个名为App的类 src/test/java测试代码目录及一个名为AppTest的测试用例 webapp的项目结构图 基本内容包括： 一个packaging为war且带有junit依赖声明的pom.xml src/main/webapp/目录 src/main/webapp/index.jsp文件 src/main/webapp/WEB-INF/web.xml文件 为什么会有这样的结构的区别呢其实两个骨架除了文件目录结构上的区别外，区别就是quickstart已经将SpringBoot的配置文件application.properties给创建好了，不需要我们额外的去创建该配置文件，是传统的webapp向SpringBoot的一个转型，为了SpringBoot去制定的一个Archetype quickstart创建的是以jar包的方式，提供一个对外的统一输出 原来的webapp创建的是以war包的方式，部署在Tomcat或者JBoss这种J2EE的这种容器里面 Building a RESFul Web Service 引入对应的pom文件的spring start 依赖 Spring-boot-starter-parent 指定父pom Spring-boot-starter-web 依赖关系如下 maven 支持 jar logging jar tomcat jar web jar groupId和artifactId和version 请看maven篇 emmm 导包过程中 突然想起一道笔试题 在import语句上只可以有注释 还可以有包名 我是猪吧 🐷 8090端口被ssr占用 本地仓库老是无法更新索引 找个机会 把他弄成nexus的本地镜像仓库 现在先凑合着用 好 需要关注pom.xml的结构 @EnableAutoConfiguration 启用 Spring 应用程序上下文的自动配置，试图猜测和配置您可能需要的bean。自动配置类通常采用基于你的 classpath 和已经定义的 beans 对象进行应用。被 @EnableAutoConfiguration 注解的类所在的包有特定的意义，并且作为默认配置使用。例如，当扫描 @entity类的时候它将本使用。通常推荐将 @EnableAutoConfiguration 配置在 root 包下，这样所有的子包、类都可以被查找到。 Auto-configuration类是常规的 Spring 配置 Bean。它们使用的是 SpringFactoriesLoader 机制（以 EnableAutoConfiguration 类路径为 key）。通常 auto-configuration beans 是 @conditional beans（在大多数情况下配合 @ConditionalOnClass 和 @ConditionalOnMissingBean 注解进行使用）。 密码和用户的info信息是分开存储的 密码采用encrpt加密方式加密 @RestController注解相当于@ResponseBody ＋ @Controller合在一起的作用。 找个机会看看@Controller是怎么实现的 dao层中的UserDO和UserPasswordDO（DO-DataObject）仅仅只是 用来mapper映射的数据传输模型 真正被作为业务逻辑处理的其实是在service层的model层 它会汇集所有的来自dao不同的数据 属于同一个对象 就像info的password是属于一个对象的 但是却是来自不同的表的 添加@ResponseBody 与不添加的区别添加了之后, 返回的json 数据会直接被添加到 http response body(响应体) 中 1234567891011@RequestMapping("/manage/login")@ResponseBodypublic Student login()&#123; Student student = new Student(); student.setName("张三"); student.setId(1); return Student; // 返回的是 Student 转换成的 json 形式的数据 并且由于 ResponseBody 的注解存在 // 将 json形式的数据 直接写入到 HTTP Response Body 即响应体中 // 如果不添加 @ResponseBody 的话, 相当于返回的 url 为空, 页面的 url 不变 // 在 SpringBoot 中返回404&#125; 未添加的话, 将会根据返回的 String 形式的 url 进行跳转 1234@RequestMapping("/manage/login")public String login()&#123; return "/admin/login"; // 返回的是 String 形式的 url, 根据对应的 url 跳转请求&#125; 找机会研究一下 common-lang3 mapper.insertSelective 会对参数进行判空 如未 null 则不添加该语句的 insert , 完全依赖于数据库的默认值 1keyProperty=&quot;id&quot; useGeneratedKeys=&quot;true&quot; 将自增 id 取出, 后赋值给对应的 userModel 的 id, 自增的 id 被取出, 赋值给对应的对象 123@CrossOrigin(allowCredentials = "true", allowedHeaders = "*")// 解决跨域问题ajax 中: xhrFields:&#123;withCredentials:true&#125;, RequestMapping注解中consumes与produces的区别consumes - 消费者, 限制 HTTP Header 里的 ContentType, 客户端(即用户)可消费当前服务端(即服务器)的服务, 只能以 对应格式 进行消费, 就比如我只接收 application/json 不接收 application/xml, 就好像现在的一些不良商铺, 只接收支付宝和微信转账, 不接收现金, 要知道, 不接收现金是犯中华人民共和国人民币法的第三条法律哦! produces - 生产者, 限制 HTTP Header 里的 Accpet, 用来告诉客户端, 我只生产 对应格式 的消费对象, 我只会传给前端指定的 格式的数据 那这两个注解有什么用呢? 如果不设置的话, 好像这个注解也是可以使用的, 你不需要去指定格式类型 使用 @RequestMapping 注解的 produces 和 consumes 这两个元素来缩小请求映射类型的范围, 提高请求的处理的效率, 并可以限制开发时候的数据格式类型统一, 避免前后端传输的数据不是一种类型的, 但是却始终可以正常运行对应的数据格式, 算是一种规范化吧 hibernate-validator 好东西 如果一个service有多个实现, 那autowired是怎么实现自动注入的呢? 如何判断要注入的是哪一个impl呢? https://blog.csdn.net/caidingnu/article/details/100906554 LocalDateTime Java8 ? 12LocalDateTime now = LocalDateTime.now();now.format(DateTimeFormatter.ISO_DATE); Spring.mvc.throw-exception-if-no-handler-found=true Spring.resources.add-mappings=false 处理未处理异常 使其跳转后 可自定义404页面 12// 捕获所有的异常类@ControllerAdvice 项目源代码已经部署完成, 新的目标 项目云端部署 jmeter性能yace 如何发现系统瓶颈问题 JMeter性能压力测试我们的压力测试针对的接口是秒杀商品详情页的接口 针对起进行高并发性能压测 通过jmeter工具设置线程组同时进行线程的数量，同时发送http请求10执行100次 循环执行15次，结果树和聚合报告 聚合报告可以看出 pstree -p | wc -l 命令 查看所有正在执行的java程序并发的线程总数 看看最高达到多少的线程值 通过top -H 线程数量大概在33 到 43 就上不去了 线程数量上不去的原因内嵌Tomcat配置 server.tomcat.accept-count: 等待队列长度 默认100 server.tomcat.max-connections: 最大可被连接数，默认为10000 server.tomcat.max-threads：最大可工作线程数，默认为200 server.tomcat.min-spare-threads：最小工作线程数，默认为10 默认配置下，连接超过10000后出现拒绝连接情况 默认配置下，触发的请求超过200+100后拒绝处理 我的电脑是四核八线程的 最大开了800的线程 docker容器间的连接 centos 容器和mysql容器的连接 通过link 进行连接 现在有一种比较新的方式 docker官方文档也是推荐大家去使用的 叫什么 容器网络的形式 还没去用过 有打算去试试看 既然叫网络 那当然是一种容器间连接的一种管理 肯定比link要方便许多 而我折腾的那一些 还可以用link支撑的来 连一下mysql redis还是可以的 上去了 变成472了 线程调度数 4核cpu 8G 内存 大概 800～1000以上的线程数 定制tomvat spring容器中的 webconfiguration 定制keepalivetimeout 多少毫秒后不响应断开连接 maxKeepAliveRequest 多少次请求后keepalive断开失效 保证客户使用服务高并发的情况下 保证服务的正常运行 等待队列长度：队列做缓存池，不能设置过长，会消耗内存，出对入队也会消耗cpu 这种情况下，需要添加服务器 sql中 查询消耗时间的话 主键查询可能是10毫秒 唯一索引是10～100毫秒 非索引的 100～1000毫秒 更新操作也是也是 插入操作的话是 跟配置有关 还没去试过 有机会会试一下 nginx 命令 -t -s reload 阿里云 按小时计费的服务器 nginx负载均衡 配置服务器的权重 upstream配置权重 weight为1 高性能的原因 1 epoll多路复用 2 masterworker 3 协程 依附于线程 切换开销小 遇阻塞归还执行权 代码同步 无需加锁 分布式会话token登陆凭证 存到redis中 缓解登录时的 高并发的压力 1 生成登陆凭证uuid 2 简历用户与登陆凭证之间的联系 绑定在一起 一起存到 redis中 以聚合的 形式 对象聚合 redisRedis缓存的是商品详情 仅仅只是模拟集群 理论上的话 redis有两种 我们可以 设置哨兵模式的 随时心跳机制检测 redis是否挂掉 挂掉的话就转到备用的redis上去 然后在用集群的形式 部分redis用于 get 部分用于set 哨兵和集群的形式相结合 形成一种分布式集群的redis机制 如何避免脏读的事务管理 减之后的理应库存值与实际库存值做比较 Guava 本地缓存存放对象的热点数据 减少redis 的压力 填充本地缓存 本地缓存是存在内存中的 需要一定的容量上限机制与淘汰策略防止内存溢出的情况 Lua缓存工具 这时候需要lua作为文件的缓存工具 用于读取文件 1 基于协程编程 2 应该是存在本地的 异步同步数据库1 活动发布同步库存进缓存 2 下单交易减缓存库存 3 异步消息扣减数据库内库存 RokketMQ原理1 broker 突破点 是因为 topic 由此依附而生的 消息队列 从而进行对应的消费队列 2 producer 发现broker 针对broker。处理 生成 consumer 3 解耦 限流 削峰 我们可以通过设置只接收5000个请求，不再允许有多的请求，超过的请求将不处理或返回下单失败， 这个过程中，将订单系统与库存系统进行了解耦，本来的下订单，是与减库存，绑在一起的，有了消息队列之后，下订单和减库存的中间多了个消息队列，下订单的请求将会到达消息队列，而减库存的服务去订阅消息队列中的服务，请求在消息队列中，实现了限流与削峰的机制，防止服务器由于流量过大而崩溃 项目面试总结秒杀过程：1 检查用户是否进行登录，未登陆的话，则提示未登录，跳转至登录页面 2 登陆后，跳转至商品列表页 3 在商品列表页点击，点击想要购买的商品，跳转至商品详情页 4 1 若现在处于商品秒杀阶段 则商品开放购买接口，实现秒杀 2 若现在未处于商品秒杀阶段 则不开放购买接口，商品售卖倒计时 5 商品被点击购买后，若购买成功，则秒杀完成；购买失败，则弹窗购买失败 秒杀的整个流程大概就是这样子 问题集：1 是如何进行用户登录的 首先有一个存放每一个用户的信息的表，叫user_info，用户信息的表中存放了用户id，用户手机号，加密过的用户密码，用户地址，用户性别和第三方凭证等信息，由于用户登录是一个可能有高并发的场景，所以我又开了一个表，叫user_login，专门存放user_id和用户密码，当然还有每条记录的主键id。用户登录登录需要访问信息表，得到user_id，再访问用户登录表，获取用户的密码，校验密码后实现登录； 登录之后，一开始是将用户登陆的状态改成true和除了密码之外的用户信息，存到session中 但如果要用到分布式，nginx反向代理实现分布式的话，session就没用了，因为session是存在本地的服务器上的，我们这时候用户登陆的凭证是无法保证存放在一个位置的，你可能登陆完之后，跳转值秒杀页面想要进行秒杀，他还是会显示你未登录，因为你已经跳转到另一个服务器了 后来改成了生成登录的唯一凭证randomUUID，将UUID和用户信息绑在了一起，改成存到redis中，每次从服务器的redis中读取用户登录状态， 后来改成了 1.1 如果用户存在多个地址（或者其他XX），你应该怎么处理呢？ 专门开多另一张表来存放用户的地址或者XX，如果数量多则分表，如果经常访问加索引加redis，如果并发量过高，加redis集群加分布式 1.2 用户的密码是如何加密的 我的项目中是使用MD5的Hash加密方式，但像CRC和MD5这种定向加密的方式，现在貌似已经不安全了，因为有可能以一种类似Hash碰撞的形式被破解，我们可以在这个的基础上再加的随机盐值，加大他针对表数据的破解难度 1.3 为什么user_login存的是user_id 而不是 用户账号 因为用户的登录方式可以是手机，可能是邮箱，可能是微信和第三方等信息，我们可以根据他登录的凭证都多样化的设置登录方式，如果是手机和邮箱登录的话，则需要再次访问user_login表的加密后的密码，加密后的密码和输入后加密的密码是否一致，一致即登录成功；如果用的是微信或者第三方登录，我们将引入第三方的接口，如果第三方返回的登录成功信息为正确，即登录成功，无需再访问user_login表 1.3.1 为什么要专门把加密后的密码 单独拿出来存放在user_login表中呢？ 因为其实 密码的用途仅仅是用来用户登录，我们有必要将用户密码的模块单独拿出来，单独实现登录，而用户除了密码的其他信息，可以实现查看用户信息的功能，用户信息是不需要密码的，如果将密码添加到用户信息表中，不仅会因为关键字的数量增加而导致查询sql执行速度降低，而且用户信息是会被修改的，在安全性的角度来讲，如果密码和用户信息在一张表的话，对表的信息进行操作的时候，可能会操作到密码，就比如注入攻击，安全性不够，所以，最好还是单独存放，操作user_login表，基于效率与安全性的角度来考虑 1.3.2 为什么会使sql语句执行速度降低？ 查询的时候查多了一列数据，速度当然会降低呀 1.3.3 为什么会被操作到密码？ 如果密码在用户信息表的话，查询用户信息的时候，sql注入攻击可能在查询的时候，得到用户的密码，也可能在修改的时候，修改用户的密码 1.4 你是怎么处理用户的高并发的 或者说你是怎么实现用户的高并发的 在mysql上，根据用户数量分库分表，一是可以实现读写分离，二是分表，降低sql语句执行的范围和维度，如果还需要的话，还可以加多个冷热分离，用户的冷表和热表，冷热分离是我在是项目上学到的 在redis上，添加redis的集群，redis的读写分离，以及备用的slave哨兵redis监控主redis的使用情况，瘫痪了替换上去，然后根据用户数量对redis进行分表，实现redis集群 1.4.1 冷热分离的具体实现？ 活跃的用户，进入热表，超过一定时间不登陆的用户，进入冷表，如果冷表的用户登录了的话，加入热表 1.5 表的记录非常多的时候，你是怎么处理的 分表咯，将用户信息表和用户登录表根据数量分表，比如说有1W个用户，按照(10000 mod 100) + 1 分为1~100个 101张表，每张表存放100个用户，降低表的维度，提高语句执行效率，加大命中率 如果有需要，还可以加多个读写分离 1.5.1 读写分离怎么解决冲突的问题？ 分主库和从库，修改的情况下，如果出现了读的语句，命中的是一条记录的话，如果对象为从库的话，不加锁的情况下，无论是先修改，还是先删除，其实只要某种情况下，导致主从不一致，主从不一致就会发生脏读。 所以解决方法就是 要么直接读主库 要么加锁 让相应的操作同步执行 1.6 说一下UUID是什么 可以理解为在这台机器上的唯一标识符，全局唯一，起到了一个主键的作用。 2 登陆后的商品列表页具体是怎么实现的，有没有什么优化方案 首先数据是从哪里来的呢，数据是从数据库来的，我在数据库里建了个item表专门存商品信息，商品信息有商品id 商品名字 商品价格 商品销量 和商品图片链接，由于商品库存在秒杀的时候是会被频繁访问的，所以我专门开了个表用来存商品库存item_stock，里面有主键id、商品库存和商品ID，用户访问商品详情的时候，就会先访问商品信息表item，再根据商品id来查询库存表item_stock里的库存，然后根据数据渲染页面 如果说是优化方案的话，我觉得如果有需要的话，可以将在秒杀活动期间的商品，把他们做一个推荐，推荐的形式可以有很多种，我们在这里的话，由于页面也比较简单，将对应商品推荐到列表首位，活动期间商品也做一个排序，排序的依据是距离秒杀开始的时间，升序排序 2.1 库存有必要实时更新吗？ 库存在列表页没有必要实时更新吧，因为你本来秒杀就是一个高并发高访问库存表，你如果实时更新库存的话，只会给库存表的数据库层增加负担，没必要吧。 2.2 你针对库存有什么优化方案吗，库存表被频繁访问？ 在已经分库分表的情况下，详情请看9.1 3 商品详情页是怎么实现的 商品详情页是可能被频繁访问与刷新的，我将商品详情页加上了redis缓存，保证高可用，分库读还是写 分表 这里好像没用到 写 只用到了读 分表的话 减少维度 10000%10这样子 去减少维度， 4 商品详情页有什么需要遍历或者显示的信息，商品的信息有哪些 5 是如何实现秒杀的 6 是如何控制并发量 接收高并发的 7 你是怎么发现并发问题的 8 你的某某表是怎么设计的 9 整个项目中有哪些地方使用了redis的 登录态 商品详情页 9.1 库存没有用redis ？ 用的是什么 库存的更新用的是消息队列，异步更新商品库存，rocketmq是存在硬盘上的，在硬盘上实现的消息队列 其实也可以用redis来缓存库存，甚至将redis来当作mysql来使用，实时访问redis的库存，但是这可能会无法与mysql保持一致性，数据无法保持一致性就可能会导致超卖 而且redis的思想是属于减了就不管了 redis是不支持回滚的 只会执行失败 或者 执行成功 他这是抱着一种 我执行的操作没问题 有问题也是你的逻辑或者代码有问题 把数据的错误 抛给了代码层面去处理 而不是 像mysql 有事务管理的机制 如果用redis来做库存的话，可能需要让运维费心，让运维去保证数据是没有问题的，上一点人力，手动改库存，实时检查 说跑题了 说回消息队列 消息队列的本质其实就是 实现 解耦 限流 削峰 将下订单和减库存两个服务 解耦 通过队列中的数量限制 实现限流 通过限制流量 实现削峰 限制流量之后，服务器的承受能力提升，没那么容易崩溃，保证秒杀全过程的稳定性，降低迭机的可能性 而异步实现的话，依旧有可能会下单失败之后，还是减了库存，这时候我们可能可以在逻辑上实现一个乐观锁，来保证库存的正确性，spring其实也有提供这么一种事务性消息队列应用的注解的使用，但我可能没用过 如果说订单一直没有生成成功，数据库崩了，这时候我们需要有一个超时刷新的机制，保证整个流程的顺利进行 9.2 说到削峰，还有没有什么更好的办法，如果用户频繁刷新，这个并发量可是非常大的 削峰的话，用户流量我们可以也给用户加个秒杀令牌，当用户持有秒杀令牌的情况下，才能进行秒杀 9.3 那异步实现的话 可能会出现异步消息发送失败 库存没见成功 或者扣减成功没通知 下单后 无法保证库存的正确 可能少了 怎么办 我们可以加日志流水，我们开一个专门的流水存放表，每下一笔订单，生成一个流水记录，流水记录有流水号，商品id，商品数量，再加一个流水的状态，流水号可以用uuid生成，通过流水号建立联系后，判断状态字段是否为秒杀成功 10 你用的服务器都是分开的吗 实习项目 稍微整理一下把gp_game_uin其实就是 一个专门对游戏角色进行读和写操作的接口 这个服务中 根据写的protobuf协议 一共有X个功能 获取gameUIn 也是用redis缓存，并且分了mysql表，按照mod10分了10个表，缓存也分了10个 通过gameUIn获取 uid 通过uid获取所有的用户角色 根据游戏id获取所有的游戏角色 添加游戏角色即小号 清除缓存 因为某些业务需求，我在这个服务上去添加了删除用户登录的缓存以及删除获取所有的游戏角色的缓存 更新角色信息 困难首先留下这份代码的前人，写这份代码写的非常没有包容性，让我一个实习生竟然接触到了一份这么糟糕的代码，有非常多的可以复用的结构，或者说服用的某个函数方法，这份遗留代码是将这些东西写死在里面，所有的东西都是像写流水账一样的写写写，所以我写这份代码其实很大程度上是把他重构一遍，尽量让重复执行的东西，写成一个框架，然后，反复利用，我一开始对于这种代码是很抵触的，因为缺乏经验，其实有些害怕，想的没那么全面，不过重构了之后，感觉好像，能接受了，反正不就是一改嘛，改就完事了，慢慢改，所以实习还是很重要的，可以接触到真实的业务开发这种场景，心态就变了 还有的技术上的困难的话，就是我的redis的主从一致性的问题了 PHP项目邀请链接： 链接的url 携带了 平台id 意思就是 是来自果盘的 还是来自66的 然后 追加经过urlencode变化过后的uid 再追加一个land 表示落地页 的意思 防刷的层面上就做了 验证码 挺影响用户体验的 还做了 一个表 专门记录 判断是否已经邀请过了 邀请过的话 就拒绝邀请 如果要做优化的话 可能怕他一直刷 强行增加数量的话 那就加个锁呀 处理一下]]></content>
      <categories>
        <category>notFinished</category>
      </categories>
      <tags>
        <tag>notFinished</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Java内存泄漏的思考]]></title>
    <url>%2F2019%2F05%2F08%2FJava%2F%E5%85%B3%E4%BA%8EJava%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[关于Java内存泄漏的思考Java内存回收的机制Java虚拟机针对垃圾回收有一套自己的良好的机制, 但是, 即便在Java看似完美的垃圾回收机制下, 除了内存溢出 Out of memory 和 堆栈溢出 Stack overflow 两大异常之外, 其实还有内存溢出 Memory leak的现象 Java内存泄露引起的原因内存泄漏是指无用对象(不再使用的对象)持续占有内存或无用对象得不到内存释放, 从而造成的内存空间的浪费称为内存泄漏. 内存泄漏不严重的时候, 根本察觉不到, 但严重时, JVM会抛出Out of memory的异常 根本原因长生命周期对象对短生命周期对象的引用, 导致内存泄漏 尽管短生命周期已经不需要再被使用, 但长生命周期对象持有对它的引用而导致JVM不能对其进行回收, 造成内存泄漏 静态集合类的内存泄漏 静态集合类Static Vector 或者 Static HashMap 的生命周期和应用程序是一致的, 他们所引用的所有的对象Object也不能被释放 123456Static Vector v = new Vector(10);for (int i = 1; i&lt;100; i++) &#123; Object o = new Object(); v.add(o); o = null;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发常见方法]]></title>
    <url>%2F2019%2F05%2F07%2F%E5%B9%B6%E5%8F%91%2F%E5%B9%B6%E5%8F%91%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[并发常见方法sleep方法sleep是Thread类的静态方法, 暂停当前线程的活动, 休眠指定的毫秒数, 会抛出InterruptedException异常 run方法Runnable是接口, 实现多线程的方式之一, 直接调用run方法, 只会执行同一线程中的任务, 而不会启动新线程. start方法调用Thread.start方法, 这个方法将创建一个执行run方法的新线程, 在底层创建新线程之后, 会执行run方法 return方法正常结束, 或者中断进程 Stop方法其他线程可以调用它终止线程, 已被弃用, 弃用的原因是 stop方法是终止当前线程所有未结束的方法, 当线程被终止时, 立即释放所有相关对象的锁, 导致对象处于与原来不一致的状态, 且无法还原 Suspend方法挂起一个持有一个锁的线程, 不释放锁, 该锁在回复之前都是不可用的, 很容易造成死锁 resume方法唤醒一个被挂起的线程, 该方法在suspend方法后调用 线程运行的状态 new 新创建 runnable 可运行 一旦启用start方法, 线程则处于runnable状态 可运行分为 正在运行 没有运行 没有运行则可能是 以下三种状态的一种 blocked 阻塞 请求锁 得到锁后 变成可运行状态 waiting 等待 等待通知 被通知后 变成可运行 timed waiting 超时等待 等待通知 被通知或者超时后 变成可运行 terminated 被终止 执行exits方法 getState方法获取一个线程的当前状态 被终止的线程 原因有两种 因为run方法正常退出return而自然死亡 因为一个没有捕获的异常throws终止了run方法而意外死亡 stop杀死一个线程的时候, 该方法抛出ThreadDeath错误对象异常, 由此杀死线程 join方法等待指定线程终止, 可带参数, 指等待指定毫秒数 守护进程为其他线程提供服务, 比如ftp服务, 若所有进程中, 只有守护进程在运行, 虚拟机就会退出, 守护进程不应该去访问固有资源例如数据库, 因为守护进程随时可能被一个操作中断 竞争条件两个或两个以上的线程需要共享同一个数据的存取, 则存在竞争条件 可重入锁RenntrantLock类通过创建可重入锁的实力, 临界区的开始调用lock方法, 一般用try catch finally代码块限制临界区确保临界区的代码执行完之后, finally块需要释放锁unlock(), 可重入锁有一个对象持有数计数器, 用于锁的嵌套调用, 表明目前持有的对象数量, 当持有计数为0时, 线程释放锁 可重入锁可以有多个条件对象, 根据条件对象来让线程进入条件的等待集中 锁被释放的时候, 调用signalAll接触该条件的等待集中的所有线程的阻塞状态 若调用signal方法, 该条件会随机选择一个线程 释放其阻塞状态 这种方法有风险 如果该线程不满足条件的话 其他被阻塞的线程就永远都不会再运行了, 就造成死锁的现象了 ReentrantLock的构造方法可以构造一个公平策略的可重入锁, 公平锁会优先选择等待时间最长的线程, 即便是这样, 如果线程调度器因为策略选择忽略这个线程, 即便这个线程等待了很长时间, 他也会被忽略, 不能确保完全公平 Synchronized内在锁 固有锁对象自带的内部所, 和lock不一样的是, 内部对象锁只可以有一个相关条件 用wait方法添加一个线程到等待集中, 用notifyAll/ notify接触等待线程的阻塞状态, notify同样也是随机接触一个线程, 有死锁的风险 死锁的场景可重入锁或者同步对象锁 用signal或者notify随机唤醒一个线程, 导致死锁 suspend方法挂起一个线程后, suspend是不会释放锁的, 若线程试图获取同一个锁, 程序会变死锁 MySQL并发修改同一记录或封锁同一范围导致相互等待]]></content>
      <categories>
        <category>并发</category>
      </categories>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库优化总结]]></title>
    <url>%2F2019%2F05%2F07%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[数据库优化总结数据库优化的目的避免出现页面访问错误** 由于数据库链接timeout产生的页面5xx错误 由于慢查询造成页面无法加载 由于阻塞造成数据无法提交 增加数据库的稳定性** 很多数据库问题都是由于低效的查询引起的 优化用户体验 流畅页面的访问速度 良好的网站功能体验 如何进行数据库优化?针对SQL语句进行优化 借用相关工具对SQL语句的执行进行检测, 针对查询次数多锁占有时间长的 磁盘IO的内存大的 未命中索引的SQL 进行优化, 找出了对应的SQL语句之后, 借助explain语句查询和分析SQL的执行计划, 针对执行计划进行优化, 通过执行计划的extra列可得到他是否有是由临时表来存储结果, 需要进行额外的步骤对返回的行进行排序, 是否使用了索引, 针对执行计划来对SQL语句进行优化, 没有使用索引的要尽量使用索引 有使用临时表来存储结果的要尽量避免, 子查询有时候就会需要使用临时表来存储结果, 将子查询改成连接查询, 同时要注意连接查询是否存在一对多的关系 可能存在重复数据 需要去重 说到索引 尽量使where order by 后面的条件字段 索引字段越小越好 针对联合索引, 离散度大的列要放在最前面 避免重复索引和冗余索引, 我们同样可以使用相关工具对索引进行一系列的检测, pt系列的工具 删除不需要的索引 数据存储方面, 要选择合适的数据类型 使用可以存下数据的最小数据类型, 例如id用11位能存 就不要开20位来存 尽量使用简单的数据类型 例如int要比varchar类型在mysql处理上简单 尽可能使用not null定义字段 这样MySQL不需要针对每种不同字段额外定义空字段 表的范式化优化 要让表符合第三范式, 不存在传递函数依赖 表的反范式优化 有时候, 需要频繁获取较多的信息需要跨越多个表进行查询, 我们这时候就要让表有冗余数据, 方便查询 表的垂直拆分 把原来一个有很多列的表拆分成多个表, 解决表的宽度问题 把不常用的字段的单独放到一个表中 把大字段单独放到一个表中 把经常一起使用的字段放到一个表中 表的水平拆分 为了解决单表的数据量过大的问题, 水平拆分的表每一个表的结构都是一致的, 例如针对id进行hash运算, 取模5后, 为0的值为一个表, 为1 的值为一个表 为2的值为一个表 等等 数据库系统配置优化 linux系统\ tcp支持的队列数量 打开文件数的最大值限制 MySQL 设置配置文件的一些值 例如连接池的最大数量 服务器硬件优化 加大内存 不是cpu越多越好 有些工作只用到单核cpu 针对io的策略进行优化]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>DataBase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库优化]]></title>
    <url>%2F2019%2F05%2F06%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[数据库优化的目的 避免出现页面访问错误 由于数据库链接timeout产生的页面5xx错误 由于慢查询造成页面无法加载 由于阻塞造成数据无法提交 增加数据库的稳定性 很多数据库问题都是由于低效的查询引起的 优化用户体验 流畅页面的访问速度 良好的网站功能体验 硬件为CPU IO 内存的改善 只能减少阻塞的可能, 成本高且效果不明显 系统配置为TCP/IP允许通过的文件数, 若已打开文件数已经达到了最大值, 无法被开启的新文件就会频繁的进行IO操作, 加大磁盘IO的负担 从数据库表的层次解耦表与表之间的关系 优化SQL与索引为优化数据库最好的最根本的方式 如何发现有问题的SQL? 使用MySQL慢查询日志对有效率问题的SQL进行监控 1234show variables like &apos;slow_query_log&apos;;set global slow_query_log_file = &apos;&apos;;set global log_queries_not_using_indexes = on;set global long_query_time = 0; 慢查询日志所包含的内容 MySQL慢查询日志分析工具之mysqldumpslowMySQL自带的日志分析查询工具 mysqldumpslow 有关的信息较少, 只有SQL语句的运行时间 锁的持有时间 查询得到的行数 还有更好的工具 MySQL慢查日志的分析工具之 pt-query-digest 纵观分析结果图1 有显示总查询和实际普通查询的数量, 可表示查询的优化程度 总查询数量和实际普通查询数量为1 : 9 说明把9000个查询抽象成了1000多个查询 针对执行时间 锁的持有时间 总共发送的行数 扫描的行数 扫描的行数大于发送的行数 说明了表的索引以及SQL语句没有优化好 纵观分析结果图2 按照表的调用次数和响应时间进行排序, 可明显看到哪个表是被访问的次数是最多的 纵观分析结果图3 针对指定sql语句的执行次数和锁持有时间 对指定sql语句进行分析 如何通过慢查询日志发现有问题的SQL? 查询次数多且每次查询占有时间长的SQL, 通常为pt-query-digest分析的前几个查询 IO大的SQL, 注意pt-query-digest分析中的Rows examine项 未命中索引的SQL, 注意pt-query-digest分析中Rows examine 和 Rows Send 的对比 通过explain查询和分析SQL的执行计划 table 显示这一行的数据是关于哪张表的 type 这是重要的列, 显示连接使用了何种类型. 从最好的到最差的链接类型为const eq_reg ref range index ALL possible_keys 显示可能应用在这张表中的索引, 如果为空, 没有可能的索引 key 实际使用的索引, 如果为null, 则没有使用索引 key_len 使用索引的长度, 在不损失精确性的情况下, 长度越短越好 ref 显示索引的哪一列被使用了, 如果可能的话, 是一个常数 rows MYSQL认为必须检查的用来返回请求数据的行数 Max()的优化 Count()的优化 count(*)是包括null的 子查询的优化 为什么join查询方式比子查询的方式速度更快呢? 因为join查询不需要内建临时表处理. use temporary Group by的优化优化前 优化后 Limit的优化优化前 优化后 随着数量的增加 IO增大 如何选择合适的列建立索引? 索引的维护及优化—重复及冗余索引索引过多会降低查询和写入的效率 select insert update 因为在查询或写入的时候 MySQL首先会选择使用哪一个索引进行查询 如果索引越多 分析的过程就会越慢 所以所以过多会影响效率 重复索引 冗余索引 如何查找重复及冗余索引使用sql语句 使用pt-duplicate-key-checker 索引维护方式 选择合适的数据类型 数据库表的范式化优化 第一范式（1NF）是指数据库表的每一列都是不可分割的基本数据项 第二范式（2NF）要求实体的属性完全依赖于主关键字 第三范式（3NF）：如果关系模式R（U，F）中的所有非主属性对任何候选关键字都不存在传递依赖，则称关系R是属于第三范式的。 BCNF：如果关系模式R（U，F）的所有属性（包括主属性和非主属性）都不传递依赖于R的任何候选关键字，那么称关系R是属于BCNF的。或是关系模式R，如果每个决定因素都包含关键字（而不是被关键字所包含），则关系R是RCNF的关系模式。 数据库的反范式化优化 数据库表的垂直拆分 数据库表的水平拆分 数据库系统配置优化 MySQL配置文件优化 第三方配置工具 服务器硬件优化]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>DataBase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux硬链接与软链接]]></title>
    <url>%2F2019%2F05%2F06%2FLinux%2FLinux%E7%A1%AC%E9%93%BE%E6%8E%A5%E4%B8%8E%E8%BD%AF%E9%93%BE%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[转载自: https://www.cnblogs.com/crazylqy/p/5821105.html Linux 系统中有软链接和硬链接两种特殊的“文件”。 软链接可以看作是Windows中的快捷方式，可以让你快速链接到目标档案或目录。 硬链接则透过文件系统的inode来产生新档名，而不是产生新档案。 磁盘分区会被分为两个部分: Inode区 与 Data Block(实际数据放置在数据区域中) Inode是文件在文件系统中的唯一标识 访问一个文件的时候必须先找到并读取这个文件的Inode Inode里面存储了文件的很多重要参数, 其中唯一标识称为Inumber, 创建时间ctime, 修改时间mtime, 文件大小, 属主 归属的用户组, 读写权限, 数据所在的block号等信息 磁盘分区会根据inode的数量进行分区, 比如文件数量很多而文件都很小, 则需要Inode的数量就会较多, 方便索引全部文件 Inode不记录文件名, 文件名记录在目录文件的Block中 硬链接: 多个档名对应同一个Inode, 借助Inode来产生新的档名, 从而产生新的档名链接 硬链接 命令：ln 多个档名对应同一个inode，硬链接只是在某个目录下新增一笔档名链 接到某个inode号码的关联记录而已。如果将上图中任何一个档名删除，档案的inode与block都还存在，依然还可以通过另一个档名来读取正确的档 案数据。此外，不论用哪一个档名来编辑，最终的结果都会写入相同的inode和block中，因此均能进行数据的修改。 软连接 命令：ln -s 软连接就是建立一个独立的文件，而这个文件会让数据的读取指向它link的那个档案的档名，由于只是作为指向的动作，所以当来源档案被删除之后，软连接的档案无法开启，因为找不到原始档名。连结档的内容只有档名，根据档名链接到正确的目录进一步取得目标档案的inode，最终就能够读取到正确的数据。如果目标档案的原始档名被删除了那么整个环节就进行不下去了。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux常见命令]]></title>
    <url>%2F2019%2F05%2F06%2FLinux%2FLinux%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[部分转载自: JavaGuide开源项目 Github-后端程序员必备的Linux基础 Linux支持的5种文件类型普通文件 目录文件 链接文件 设备文件 命名管道FIFO 关于链接的种类有: 硬链接和软连接 可点击跳转 查看 Linux硬链接与软连接 目录切换命令 cd usr： 切换到该目录下usr目录 cd ..（或cd../）： 切换到上一层目录 cd /： 切换到系统根目录 cd ~： 切换到用户主目录 cd -： 切换到上一个操作所在目录 目录的操作命令 mkdir 目录名称： 增加目录 ls或者ll（ll是ls -l的别名，ll命令可以看到该目录下的所有目录和文件的详细信息）：查看目录信息 find 目录 参数： 寻找目录（查） 示例： 列出当前目录及子目录下所有文件和文件夹: find . 在/home目录下查找以.txt结尾的文件名:find /home -name &quot;*.txt&quot; 同上，但忽略大小写: find /home -iname &quot;*.txt&quot; 当前目录及子目录下查找所有以.txt和.pdf结尾的文件:find . \( -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot; \)或find . -name &quot;*.txt&quot; -o -name &quot;*.pdf&quot; mv 目录名称 新目录名称： 修改目录的名称（改） 注意：mv的语法不仅可以对目录进行重命名而且也可以对各种文件，压缩包等进行 重命名的操作。mv命令用来对文件或目录重新命名，或者将文件从一个目录移到另一个目录中。后面会介绍到mv命令的另一个用法。 mv 目录名称 目录的新位置： 移动目录的位置—剪切（改） 注意：mv语法不仅可以对目录进行剪切操作，对文件和压缩包等都可执行剪切操作。另外mv与cp的结果不同，mv好像文件“搬家”，文件个数并未增加。而cp对文件进行复制，文件个数增加了。 cp -r 目录名称 目录拷贝的目标位置： 拷贝目录（改），-r代表递归拷贝 注意：cp命令不仅可以拷贝目录还可以拷贝文件，压缩包等，拷贝文件和压缩包时不 用写-r递归 rm [-rf] 目录: 删除目录（删） 注意：rm不仅可以删除目录，也可以删除其他文件或压缩包，为了增强大家的记忆， 无论删除任何目录或文件，都直接使用rm -rf 目录/文件/压缩包 文件的操作命令 touch 文件名称: 文件的创建（增） cat/more/less/tail 文件名称 文件的查看（查） cat： 查看显示文件内容 more： 可以显示百分比，回车可以向下一行， 空格可以向下一页，q可以退出查看 less： 可以使用键盘上的PgUp和PgDn向上 和向下翻页，q结束查看 tail-10 ： 查看文件的后10行，Ctrl+C结束 注意：命令 tail -f 文件 可以对某个文件进行动态监控，例如tomcat的日志文件， 会随着程序的运行，日志会变化，可以使用tail -f catalina-2016-11-11.log 监控 文 件的变化 vim 文件： 修改文件的内容（改） vim编辑器是Linux中的强大组件，是vi编辑器的加强版，vim编辑器的命令和快捷方式有很多，但此处不一一阐述，大家也无需研究的很透彻，使用vim编辑修改文件的方式基本会使用就可以了。 在实际开发中，使用vim编辑器主要作用就是修改配置文件，下面是一般步骤： vim 文件——&gt;进入文件—–&gt;命令模式——&gt;按i进入编辑模式—–&gt;编辑文件 ——-&gt;按Esc进入底行模式—–&gt;输入：wq/q! （输入wq代表写入内容并退出，即保存；输入q!代表强制退出不保存。） rm -rf 文件： 删除文件（删） 同目录删除：熟记 rm -rf 文件 即可 压缩文件的操作命令1）打包并压缩文件： Linux中的打包文件一般是以.tar结尾的，压缩的命令一般是以.gz结尾的。 而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般.tar.gz。 命令：tar -zcvf 打包压缩后的文件名 要打包压缩的文件 其中： z：调用gzip压缩命令进行压缩 c：打包文件 v：显示运行过程 f：指定文件名 比如：加入test目录下有三个文件分别是：aaa.txt bbb.txt ccc.txt，如果我们要打包test目录并指定压缩后的压缩包名称为test.tar.gz可以使用命令：tar -zcvf test.tar.gz aaa.txt bbb.txt ccc.txt或：tar -zcvf test.tar.gz /test/ 2）解压压缩包： 命令：tar [-xvf] 压缩文件 其中：x：代表解压 示例： 1 将/test下的test.tar.gz解压到当前目录下可以使用命令：tar -xvf test.tar.gz 2 将/test下的test.tar.gz解压到根目录/usr下:tar -xvf xxx.tar.gz -C /usr（- C代表指定解压的位置） Linux的权限命令操作系统中每个文件都拥有特定的权限、所属用户和所属组。权限是操作系统用来限制资源访问的机制，在Linux中权限一般分为读(readable)、写(writable)和执行(excutable)，分为三组。分别对应文件的属主(owner)，属组(group)和其他用户(other)，通过这样的机制来限制哪些用户、哪些组可以对特定的文件进行什么样的操作。通过 ls -l 命令我们可以 查看某个目录下的文件或目录的权限 示例：在随意某个目录下ls -l 第一列的内容的信息解释如下： 下面将详细讲解文件的类型、Linux中权限以及文件有所有者、所在组、其它组具体是什么？ 文件的类型： d： 代表目录 -： 代表文件 l： 代表软链接（可以认为是window中的快捷方式） Linux中权限分为以下几种： r：代表权限是可读，r也可以用数字4表示 w：代表权限是可写，w也可以用数字2表示 x：代表权限是可执行，x也可以用数字1表示 文件和目录权限的区别： 对文件和目录而言，读写执行表示不同的意义。 对于文件： 权限名称 可执行操作 r 可以使用cat查看文件的内容 w 可以修改文件的内容 x 可以将其运行为二进制文件 对于目录： 权限名称 可执行操作 r 可以查看目录下列表 w 可以创建和删除目录下文件 x 可以使用cd进入目录 需要注意的是超级用户可以无视普通用户的权限，即使文件目录权限是000，依旧可以访问。 在linux中的每个用户必须属于一个组，不能独立于组外。在linux中每个文件有所有者、所在组、其它组的概念。 所有者 一般为文件的创建者，谁创建了该文件，就天然的成为该文件的所有者，用ls ‐ahl命令可以看到文件的所有者 也可以使用chown 用户名 文件名来修改文件的所有者 。 文件所在组 当某个用户创建了一个文件后，这个文件的所在组就是该用户所在的组 用ls ‐ahl命令可以看到文件的所有组 也可以使用chgrp 组名 文件名来修改文件所在的组。 其它组 除开文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组 我们再来看看如何修改文件/目录的权限。 修改文件/目录的权限的命令：chmod 示例：修改/test下的aaa.txt的权限为属主有全部权限，属主所在的组有读写权限， 其他用户只有读的权限 chmod u=rwx,g=rw,o=r aaa.txt 上述示例还可以使用数字表示： chmod 764 aaa.txt 补充一个比较常用的东西: 假如我们装了一个zookeeper，我们每次开机到要求其自动启动该怎么办？ 新建一个脚本zookeeper 为新建的脚本zookeeper添加可执行权限，命令是:chmod +x zookeeper 把zookeeper这个脚本添加到开机启动项里面，命令是：chkconfig --add zookeeper 如果想看看是否添加成功，命令是：chkconfig --list 跨机器文件的相互拷贝从192.0.0.101的temp/下 复制var下的所有文件 到本地的test目录下 1# scp root@192.0.0.101:/temp/var/* /test/ 将本地temp/var/下的所有文件 复制到192.0.0.101的test目录下 1# scp /temp/var/* root@192.0.0.102:/test/ Vim编辑器下的常用命令跳转至指定25行 25G 查看负载的三种方式Linux查看负载的三种方式 查看文件的相关指令Word Count 工具命令大全查看指定文件的行数 wc -l(或者–lines) file.log 查看指定文件的字节数 wc -c(或者–bytes) file.log 查看指定文件的字符数 wc -m(或者 –chars) file.log 查看指定文件的最长行的长度 wc -L(或者 –max-line-length) file.log 查看指定文件的总字数 wc -w(或者 –words) file.log 查看帮助 wc –help 查看档案(文件)内容的相关行数命令head命令 从头查询(前n个XXX)的命令查看指定文件的前n个字节内容 head -c(或者 –bytes) 100 file.log 查看指定文件的前n行的内容 head -l(或者 –lines) 100 file.log 查看帮助 head –help tail命令 从尾查询(后n个XXX)的命令(重点重点!!!!)动态加载指定文件的内容(当文件增长时, 输出后续添加的数据) tail -f(或者–follow) file.log (一般会用tail -f catalina.log 查看tomcat的日志) 退出按Ctrl+Z或者Ctrl+C Ctrl+Z会挂起当前tail进程 后面有关于退出指令的区别描述 查看指定文件的后n个字节 tail -c(或者 –bytes) 100 file.log 查看指定文件的后n行 tail -n(或者 –lines) 100 file.log 查看帮助 tail –help 查看版本号 tail –version Linux Ctrl+C Ctrl+Z Ctrl+D的区别ctrl-c: ( kill foreground process ) 发送 SIGINT 信号给前台进程组中的所有进程，强制终止程序的执行； ctrl-z: ( suspend foreground process ) 发送 SIGTSTP 信号给前台进程组中的所有进程，常用于挂起一个进程，而并非结束进程，用户可以使用使用fg/bg操作恢复执行前台或后台的进程。 fg 命令在前台恢复执行被挂起的进程，此时可以使用ctrl-z再次挂起该进程，bg 命令在后台恢复执行被挂起的进程，而此时将无法使用ctrl-z再次挂起该进程； 一个比较常用的功能： 正在使用vi编辑一个文件时，需要执行shell命令查询一些需要的信息，可以使用ctrl-z挂起vi，等执行完shell命令后再使用fg恢复vi继续编辑你的文件（当然，也可以在vi中使用！command方式执行shell命令但是没有该方法方便） ctrl-d: ( Terminate input, or exit shell ) 一个特殊的二进制值，表示 EOF，作用相当于在终端中输入exit后回车； Linux Grep 正则表达式的使用pattern正则表达式主要参数：\： 忽略正则表达式中特殊字符的原有含义。(转义)^：匹配正则表达式的开始行。$: 匹配正则表达式的结束行。\&lt;：从匹配正则表达式的行开始。>：到匹配正则表达式的行结束。[ ]：单个字符，如[A]即A符合要求 。[ - ]：范围，如[A-Z]，即A、B、C一直到Z都符合要求 。。：所有的单个字符。* ：有字符，长度可以为0。 grep命令使用简单实例$ grep ‘test’ d*显示所有以d开头的文件中包含 test的行。$ grep ‘test’ aa bb cc显示在aa，bb，cc文件中匹配test的行。$ grep ‘[a-z]{5}’ aa显示所有包含每个字符串至少有5个连续小写字符的字符串的行。$ grep ‘w(es)t.*\1′ aa如果west被匹配，则es就被存储到内存中，并标记为1，然后搜索任意个字符(.)，这些字符后面紧跟着 另外一个es(\1)，找到就显示该行。如果用egrep或grep -E，就不用”\”号进行转义，直接写成’w(es)t.\1′就可以了。 贴上Java正则表达式的捕获组 有兴趣的自行食用捕获组分为 普通捕获组和命名捕获组 https://www.runoob.com/w3cnote/java-capture-group.html Linux/Unix 时间输出妙用 date “+%Y-%m-%d %H:%M:%S”，即可输出对应格式时间参考链接：https://blog.csdn.net/jk110333/article/details/8590746 查看上下文切换次数vmstat]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux查看负载的三种方式]]></title>
    <url>%2F2019%2F05%2F06%2FLinux%2FLinux%E6%9F%A5%E7%9C%8B%E8%B4%9F%E8%BD%BD%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[转载自: https://www.cnblogs.com/zhaozhenguo666/p/5512701.html 1 uptime 显示当前机器的负载情况 2 w 显示当前机器的负载情况, 并列出所有user分别的负载情况 load average: 过去1分钟 5分钟 15分钟的负载平均值 以上两个命令为单纯的反映出负载, 还有更为使用的查看服务器负载的命令 3 top 实时监控当前的服务器负载情况, 清晰的罗列出每一个进程占有的cpu使用和内存使用, 输入q退出 Tasks: 目前的进程总数, 以及所处状态, running表示可运行进程, sleeping表示暂停进程, stopped表示停止运行, zombie表示僵尸进程, 若zombie不为0则表示进程出现问题 Cpu(s): 展示了当前CPU的状态，us表示用户进程占用CPU比例，sy表示内核进程占用CPU比例，id表示空闲CPU百分比，wa表示IO等待所占用的CPU时间的百分比。wa占用超过30%则表示IO压力很大。 Mem: [展示了当前内存的状态，total是总的内存大小，userd是已使用的，free是剩余的，buffers是目录缓存。 Swap: 同Mem行，cached表示缓存，用户已打开的文件。如果Swap的used很高，则表示系统内存不足。 按1, 可以展示出服务器有多少CPU, 以及每个CPU的使用情况 在top命令下，按shift + “c”，则将进程按照CPU使用率从大到小排序，按shift+”p”，则将进程按照内存使用率从大到小排序，很容易能够定位出哪些服务占用了较高的CPU和内存。 仅仅有top命令是不够的，因为它仅能展示CPU和内存的使用情况，对于负载升高的另一重要原因——IO没有清晰明确的展示。linux提供了iostat命令，可以了解io的开销。 输入iostat -x 1 10命令，表示开始监控输入输出状态，-x表示显示所有参数信息，1表示每隔1秒监控一次，10表示共监控10次。 没有iostat命令的话 yum/apt-get install sysstat -y 即可 其中rsec/s表示读入，wsec/s表示每秒写入，这两个参数某一个特别高的时候就表示磁盘IO有很大压力，util表示IO使用率，如果接近100%，说明IO满负荷运转。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于事务MVCC多版本并发控制的思考]]></title>
    <url>%2F2019%2F04%2F26%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2F%E5%85%B3%E4%BA%8E%E4%BA%8B%E5%8A%A1MVCC%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%E7%9A%84%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[数据库的MVCC(Multi-Version Concurrency Control)多版本并发控制事务的隔离级别 (MyISAM不支持事务, 将隔离级别是基于事务上的, 只有InnoDB支持事务隔离级别) 读未提交 Read Uncommitted 假设A向B转账 A还没提交事务 B已经发现钱变多了 A就回滚事务 B再查看钱的时候 发现钱没有变多 这就是read uncommited 造成的脏读现象 出现脏读的本质其实是操作本身修改完数据之后就立刻将锁释放掉 读已提交 Read Committed 就是将释放锁的位置调整到事务提交之后, 在此事务提交之前, 其他进程或者线程是无法对该行数据进行读取的, 但这样也有弊端, 假设AB同时对数据库**进行操作, A准备查询数据库的同时, B正在修改数据库, 而A想要查的数据是B修改前的数据, 这种现象叫做不可重复读 可重复读 Repeated Read 就是 每开始一个新的事务, 系统版本号会自动递增, (实际上是每行记录后面保存两个隐藏的列来实现的, 一列是保存了行的创建时间, 一列是保存了行的删除时间), 事务开始时的系统版本号作为事务的版本号, 用来查询的时候比较每行记录的版本是否相符 (其实这是一种乐观锁) , 然鹅即便到了如此防御的程度, 始终还有不完美的地方, 当两个并发事务的版本号一致的时候, 会导致幻读现象, 什么叫幻读呢, 就是一个事务可能读到另一个事务insert后的值, 无中生有(咦, 这条数据哪里来的! 我本来没有的呀! 难道我漏了??? 这么玄学的???) 串行化 Serializable 在上面的基础上, 将事务的数据读取范围加上间隙锁, 其他事务不能访问或修改该范围内的数据]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>DataBase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CVTE一面]]></title>
    <url>%2F2019%2F04%2F26%2F%E9%9D%A2%E8%AF%95%2FCVTE%E4%B8%80%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[多线程线程状态之间的转换 多线程中常见的方法 串行执行线程的多种方式 多线程的创建的三种方法 框架IOC原理 IOC实现过程 AOP实现过程 AOP原理 两种动态代理模式的底层实现 数据库数据库表的设计 数据库的前三范式 常见的索引形式 索引的底层实现 数据结构 B+树的插入过程]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[美团一面]]></title>
    <url>%2F2019%2F04%2F26%2F%E9%9D%A2%E8%AF%95%2F%E7%BE%8E%E5%9B%A2%E4%B8%80%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[自我介绍 介绍项目 根据项目出发问题 项目中如何实现秒杀 项目中如何防止超卖(没问我准备好的乐观锁) redis怎么用 redis底层原理有没有了解过 redis为什么可以缓解高并发 检测链表中是否存在环 mysql有什么索引 主键索引和非主键索引的区别 索引的优缺点 主键索引是什么索引 没听太懂 innodb底层是什么索引 知道什么数据结构 有看过hashmap源码吗 讲一下put方法 hashmap为什么线程不安全 从底层实现模拟线程不安全的情况 hashmap的初始容量 讲一下冒泡的过程 时间复杂度和空间复杂度的意义 联系实际分析细节 有什么要问我的 最近得了个病 叫 面试焦虑病 面试官问我问到我回答不上来 心里就想 有些没回答上来的问题 我是不是没希望了 面试官问我问的刚好都是我会的 心里就想 完了 怎么感觉问的深度还不够深 他们是不是根本不缺人 只是走下流程 我是不是没希望了]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间戳生成器]]></title>
    <url>%2F2019%2F04%2F25%2F%E5%B0%8F%E8%84%9A%E6%9C%AC%2F%E6%97%B6%E9%97%B4%E6%88%B3%E7%94%9F%E6%88%90%E5%99%A8%2F</url>
    <content type="text"><![CDATA[想着经常会改博客的生成时间, 所以写了个时间戳生成代码, 每次都不用自己一点点改时间啦 生成的时间戳输出到文件中 生成的时间戳还不如复制到剪切板 于是就查了查怎么访问剪切板 代码是.java文件, 如何将编译后的.class文件转成windows支持的.exe文件, 双击即可生成呢? 自行食用, 不搬运了, 用的是exe4j + jar包https://blog.csdn.net/zzzgd_666/article/details/80756430 我做好的 直接打开 按ctrl+v 粘贴 即可生成时间戳 链接: https://pan.baidu.com/s/1aq6a0oLLW6bJ80pGZVhf4Q 提取码: 1dve 复制这段内容后打开百度网盘手机App，操作更方便哦 输出到文件1234567891011121314151617181920212223242526272829import java.awt.*;import java.awt.datatransfer.Clipboard;import java.awt.datatransfer.StringSelection;import java.text.SimpleDateFormat;import java.util.Date;/** * Created By icebearice on 2019/4/25 19:43 */public class TimeStampGenerator &#123; public static void main(String[] args) &#123; // 生成当前时间 Date date = new Date(); // 输出到NowTime.txt File file = new File("NowTime.txt"); PrintWriter output = null; try &#123; output = new PrintWriter(file); // 将时间按照自己想要的格式格式化 SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); output.println(simpleDateFormat.format(date)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; // 记得关闭output哦 不然文件会是空的 output.close(); &#125; &#125;&#125; 输出到剪切板123456789101112131415161718192021222324252627282930import java.awt.*;import java.awt.datatransfer.Clipboard;import java.awt.datatransfer.StringSelection;import java.text.SimpleDateFormat;import java.util.Date;/** * Created By icebearice on 2019/4/25 19:43 */public class TimeStampGenerator &#123; public static void main(String[] args) &#123; // 生成当前时间 Date date = new Date(); try &#123; // 格式化时间 SimpleDateFormat simpleDateFormat = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); // 将字符串赋值到剪切板上 // 访问系统剪切板 Clipboard clipboard = Toolkit.getDefaultToolkit().getSystemClipboard(); // 字符串转换成 传输选取类型的文本 剪切板识别传输选取类型的文本 StringSelection StringSelection selection = new StringSelection(simpleDateFormat.format(date)); // 将传输选取类型文本赋值给剪切板 clipboard.setContents(selection, null); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; //output.close(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>小脚本</category>
      </categories>
      <tags>
        <tag>小脚本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[秒杀系统项目总结（未完结）]]></title>
    <url>%2F2019%2F04%2F25%2F%E9%A1%B9%E7%9B%AE%2F%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[项目的业务逻辑是: 商家添加商品库存,商品供用户进行秒杀 用户打开商品列表,选择某个商品,跳转到秒杀页面 若秒杀开启了,则用户进行秒杀商品 秒杀成功的话,买家付款,商家发货 我在项目中主要实现的部分业务逻辑是 用户打开商品列表,点击某样需要秒杀的商品 当前商品若开启秒杀,则进行秒杀 秒杀成功,则商品减库存 针对这个秒杀的过程进行优化,防止商品超卖,能达到一定的并发量 我是借助这个秒杀系统的项目,来对高并发领域进行初步的接触与学习 实现秒杀的过程(如何考虑秒杀的需求): 先对秒杀进行简单的模拟 从商品列表中,点开具体商品 然后根据数据库中存在的秒杀商品的开始时间 结束时间 库存量 进行判断 若秒杀未开启,则隐藏秒杀接口,并显示秒杀未开启 若秒杀正在进行中,分成两种情况 商品库存量未达到零,则暴露秒杀接口,并显示秒杀进行中 商品库存量达到零,则隐藏秒杀接口,并显示秒杀已结束 若秒杀已经结束,则隐藏秒杀接口,并显示秒杀已结束 如果执行了秒杀,我们记录秒杀订单,减少库存 如何防止商品超卖(库存超卖) 暴露秒杀接口后,在前端使按钮防重复,若是重复点击,会造成提交多次请求 在减库存的sql语句中的where条件中判断库存量&gt;0 如果出现超卖现象, 还有可能是因为出现了幻读现象 跳转: 关于事务MVCC多版本并发控制的思考 MySQL的默认事务隔离级别为: Repeated Read (此处可延伸事务隔离级别) 在默认隔离级别的基础上 将秒杀方法放入同步锁synchronized代码块中, 始终会有幻读问题, 于是扩大了锁的范围, 就没有幻读的现象了, 但是同步锁会严重影响并发性能 Spring事务是通过AOP实现的, synchronized代码块是在事务之内执行的, synchronized代码块执行完之后, 事务还未提交, 事务的范围大于锁的范围, 于是将同步锁加到了Controller层, 使锁的范围大于事务的范围, 就不会有幻读问题了 将事务隔离级别改成可串行化, 也是严重影响并发性能 乐观锁改进(将实际秒杀后减少的库存量与预计秒杀后减少的库存量进行比较, 若相等则提交事务, 若不相等则回滚事务) 乐观锁改进之后, 还能如何提升我们的并发量呢??? redis缓存, 作用其实就是在高并发访问多个商品的时候, 商品的种类数量超过了上限, 导致不断地重复访问数据库, 造成缓存雪崩, 处理缓存雪崩的方式是不断地进行更新缓存, 更新缓存会出现脏读, 那就不断的删除缓存 加上redis缓存, 发现当缓;存满了的时候, 缓存雪崩, 缓存就没有作用了, 于是更新缓存 发现更新缓存出现了脏读, 于是删除缓存 缓存预加载 网络延迟 调换事务顺序, 原来先减库存后查, 变成先查后减 将秒杀的数据库操作过程写成存储过程, 全权交给Mysql, 提高吞吐量 目前所遇到的问题 redis的缓存概念 如 缓存雪崩 缓存预热 缓存穿透 缓存击穿 缓存更新 redis本身在项目中存储的是序列化后的对象, 从redis中将其反序列化即可得到对象, 有对应的对象, 即可读取其的商品ID, 商品名称, 商品库存量 涉及到需要redis缓存的高并发, 必定都是读, 而不是写, redis起到的作用就是将需要读的数据存储到缓存中, 避免多次执行sql语句进行select操作 项目中存在两种高并发的情况: 原来 本来就是动态加载 但是用户还是会不断刷新 好吧 用户不断刷新的话 需要处理高并发 秒杀即将开始时, 用户不断的在秒杀商品的页面不断地刷新, 进入秒杀界面? 为什么这里不用ajax实现自动更新 然后 到点了就自动变更接口呢? 如果用ajax的话 我需要对时间一直进行判断 动态请求 等时间到了 接口直接转换成秒杀接口 那这样子整的话 ajax可以和redis结合 redis负责刷新的时候 直接读取对应商品对象 读取出来之后 利用对象中的库存量 开始时间 结束时间 来对接口进行ajax动态化 ajax会造成延迟吗? 好像不会 多个用户对同一物品进行秒杀操作, 点击秒杀后, 会产生大量秒杀请求 如何处理高并发的情况 针对用户刷新的情况 即用redis 并且更新商品页的对应信息 防止多次访问sql 获取相应商品信息 针对秒杀的并发操作, 减少行级锁持有时间, 优化sql语句 存储过程, 深度优化 还有什么优化 请听下回分解]]></content>
      <categories>
        <category>项目</category>
        <category>秒杀系统</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于数据库索引的思考]]></title>
    <url>%2F2019%2F04%2F23%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2F%E5%85%B3%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E7%9A%84%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[为什么说B+树适合做索引 而不是B树呢 索引查找过程中会产生磁盘IO消耗,相对于内存的读取,磁盘的IO消耗的数量级要更高,所以说要想索引的效率高,要尽可能的减少磁盘IO的数量,而B树每个节点都有具体指向关键字的指针,B+树则没有指向关键字的具体指针,它只需要对一个关键字盘块进行读取,B树需要对关键字盘块和对应指针盘块两个盘块进行读取,一个盘块读取的效率就是一次IO,故B+树的IO读写次数就较少一些 由于B+树存的是对关键字的索引,所以任何关键字都需要从对应索引根节点走向叶子节点的路,相对于B树而言,查询效率更加稳定一些]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>DataBase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java源码]]></title>
    <url>%2F2019%2F04%2F23%2FJava%2FJava%E6%BA%90%E7%A0%81%2F</url>
    <content type="text"><![CDATA[Java源码Map HashMap LinkedHashMap TreeMap ConcurrentHashMap HashTable1 Hash Map存放键值对 JDK1.8之后，链表长度大于阈值8，将链表转换为红黑树 要将链表转换成红黑树的table的最小结点数为64 (n - 1) &amp; hash 判断位置 jdk1.8后 hash函数 即 扰动函数 扰动一次 1.8前 扰动四次 默认容量 16 负载因子 0.75 loadFactor太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。loadFactor的默认值为0.75f是官方给出的一个比较好的临界值。 threshold = capacity * loadFactor，当Size&gt;=threshold的时候，那么就要考虑对数组的扩增了，也就是说，这个的意思就是 衡量数组是否需要扩增的一个标准。 hashCode 将key的hashCode 异或^ value的hashCode Node节点中的equals 1 先确定是否是对象本身 2 若不是对象本身, 则判断是否为相同map.entry的实例 3 若为相同实例, 才能继续判断 对应的key是否equals 对应的value是否equals HashMap中 root 方法调用 根节点 不断地返回 parent 红黑树 双向 parent left right prev resize 扩容函数 若没超最大值 则扩容两倍 newThr = oldThr &lt;&lt; 1 resize 尽量避免 因为 resize扩容之后 会将所有的oldtable值 全部重新遍历赋值到newtable中 (e = oldTab[j]) != null) 为什么要这样子写 好处是什么??? 构造方法有四种: 无参构造 指定容量大小 指定容量大小和负载因子 包含另一个”Map”的构造函数 HashMap为什么会 线程不安全 从底层的角度思考 首先 HashMap与HashTable的区别就是 HashTable加了synchronized锁 HashMap没加 其次 冲突可能出现在放置元素的put方法中,也可能出现在扩容方法resize中,我们先从put方法说起,假设版本在jdk1.8,冲突的对应链表节点的数量未超过8的情况下,假设同时有两个以上的线程出现同一个哈希碰撞,并且两个线程同时取到了冲突链表上的同一个位置,在这种情况下,必定有一个线程的值会丢失,只有一个坑可以占 另外在resize的扩容方法中,由于扩容之后,需要将所有的节点赋值给已经扩容的新表,假设存在多个线程进行扩容,同时进行的话,只有最后赋值成功的新表,才会成为新表,其他在此线程之前重新赋值的表都作废 表是以节点数组的状态存在的 HashCode为什么以一定是2的次幂(看链接)http://www.cnblogs.com/chengxiao/p/6059914.html#t3HashMap和HashTable区别 前者线程不安全, 后者线程安全,原因是因为后者加了synchronized锁 前者可以接受null的key和value, 后者不行 在单线程的情况下, 前者的性能要比后者要快 前者的初始容量为16, 扩容以指数形式扩容, 即2的倍数, 后者的初始容量为11, 扩容是两倍的原容量+1 2 LinkedHashMap 继承HashMap底层是super调用父类的无参构造方法 存在accessOrder的boolean变量 若为false则插入是有序的, 若为true,则插入和访问的顺序都是有序的, 会对里面的键值对进行排序 实则是本质上是双向链表+HashMap 面试中关于HashMap的时间复杂度O(1)的思考分四步：1.判断key，根据key算出索引。2.根据索引获得索引位置所对应的键值对链表。3.遍历键值对链表，根据key找到对应的Entry键值对。4.拿到value。 以上四步要保证HashMap的时间复杂度O(1)，需要保证每一步都是O(1)，现在看起来就第三步对链表的循环的时间复杂度影响最大，链表查找的时间复杂度为O(n)，与链表长度有关。我们要保证那个链表长度为1，才可以说时间复杂度能满足O(1)。但这么说来只有那个hash算法尽量减少冲突，才能使链表长度尽可能短，理想状态为1。因此可以得出结论：HashMap的查找时间复杂度只有在最理想的情况下才会为O(1)，而要保证这个理想状态不是我们开发者控制的。 查询插入 O(1) 删除O(n) ArrayList有序可重复 可克隆 可序列化 继承abstractList 实现list RandomAccess(快速随机访问 故用for循环遍历效率更高 但用iterator访问更安全 因为当访问的数据发生改变的时候 他会抛异常 异常是) Clonable Serializable 默认初始容量大小为10 初始为空数组 添加第一个元素后 容量才变成10 通过反射来判断对象是否符合elementData.getClass() != Object[].class 如果未指定Object, 则令elementData为默认空数组 修改实力容量为当前大小(最小化ArrayList实例)是通过copyof实现的 扩容因子为1.5 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1) 检查newCapacity是否溢出, 若溢出了则赋值为数组最大值 Integer.MAX_VALUE 同时 对象头的最大信息占用内存不可超过8个字节 为什么最大数组大小为Integer.MAX_VALUE - 8 因为8个字节用来存数组的头信息 占满32位的内存单元长度 遍历O(1) 插入删除O(n) 关于自动装箱与自动拆箱 Java中的八大数据类型都有对应的包装类 Java是以对象的形式来保存八大数据类型的, 实现真正的面向对象 三个构造函数 无参 指定容量 指定集合 copyof为重构当前数组 底层调用了arraycopy 目标函数为新数组 copyofrange是对数组进行复制 arraycopy需要目标函数,拷贝到自定义的数组中 底层采用newcapacity - mincapacity &lt; 0 代替 newcapacity &lt; mincapacity 运算更快 remove 删除对象 fastremove 删除u索引 remove调用了faseremove clear 删除所有元素addAll 追加添加 可指定位置 modCount 改变list大小的次数 扩容机制 为了避免只扩充少量频繁的拷贝的情况 导致降低性能 有着良好的扩容机制 扩容因子为1.5倍 Arrays.toArray() 得到的是Object[] 不可向下转型为其他对象类型 Arrays.toArray(T&lt;&gt;[]) 好用 那ArrayList为什么线程不安全呢从底层来讲 举个例子 比如 在当前size为0的情况下 ArrayList底层会在有第一个数据存入的时候 将容量改为初始容量 出现多个线程同时存储值进入list中 只有最后一个存储的线程的值可以存到list中 而其他的线程的值全都会丢失 而不会存入list中 尽管capacity为初始容量 16 但 size还是等于1 只有一个值存了进来 LinkedList 线程不安全 synchronizedList在任何位置高效地插入和删除的有序序列 基于 双向链表实现的 继承AbstractSequentialList 有一个头结点 一个尾节点 我们可以从头遍历 也可以从尾遍历 checkPositionIndex(index); 检查index是否在size范围内 始终会记录着first节点和last节点 Vector可变长度的数组 长度变化靠capacity 和capacityIncrement 构造方法三种 无参构造 默认构造初始容量为10 initialCapacity 初始化容量 一个参数 initialCapacity 初始化容量 capacityIncrement 容量增长值 两个参数 其中构造方法1调用构造方法2 构造方法2调用构造方法3 默认初始容量为10 默认容量增长值为0(默认扩增为两倍原长度) Stack继承Vector 线程安全 push(E) pop() peek() empty()]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串的排列]]></title>
    <url>%2F2019%2F04%2F15%2F%E7%AE%97%E6%B3%95%2F2%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97%2F</url>
    <content type="text"><![CDATA[字符串的排列 ##题目描述输入一个字符串,按字典序打印出该字符串中字符的所有排列。例如输入字符串abc,则打印出由字符a,b,c所能排列出来的所有字符串abc,acb,bac,bca,cab和cba。输入描述输入一个字符串,长度不超过9(可能有字符重复),字符只包括大小写字母。 做这道题吧，既然是排列，就回忆一下排列组合的数学知识吧。 如果字符串为abc，那就是A33 如果字符串为alibaba，那就是C73C42A22 实现了计算的全排列，看看算法应该如何实现全排列呢？ 以字符串abc为例，固定住第一个字符，然后让后面两个字符交换，如图所示 图片来源：http://www.cnblogs.com/cxjchen/p/3932949.html 以编程的思维来看，假定字符串长度为n，则循环一般是从0~n遍历一遍的，那我们要如何实现交换之后递归停止呢？ 以abc为例： 第一个字符有abc三种可能，则第一个字符遍历3次，结束条件为遍历到最后一个字符（即只剩下一个字符） 第一个字符的三种可能已经确定，我们只需考虑第二字符和第三字符，显而易见，第二字符和第三字符交换即可得到两个字符串 需要注意的是，首字符固定后，第二字符与第三字符进行交换后，需要换回来，保证不影响首字符的遍历集合 那如果是三个以上的字符呢？ 以abcde为例： 首字符有5种可能，遍历5次，每遍历一次，都要考虑首字符后面4个字符 由于首字符固定，考虑后面4个字符，同处理首字符一样 相当于每一次都在处理 固定的首字符 结束条件为遍历到最后一个字符 非常明显的递归关系，不断处理首字符，从而进行交换 紧接着，有重复问题，怎么处理？ 对于abb而言，由于我们是固定首字符，在交换首字符a与第二字符b，并且交换回来后，若发现第三个字符与第二字符相等，则不再进行交换 所以，交换规则就是，从首字符开始，每个字符与后面非重复出现的字符进行交换，结束条件为遍历到最后一个字符（即只剩下一个字符），然鹅进行递归处理 算法思路如上，可以用方法递归或循环实现吧，方法递归可能需要处理字典序问题，循环的话可以提前处理字典序，处理完后再进行循环，便不需要完事（全排列）后处理字典序 在空间上，循环不需要递归空间 在时间上，提前处理字符串的字典序会比处理完事后生成的字符串要快一些 代码随后补上，睡觉，要猝死咯~]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[思维导图]]></title>
    <url>%2F2019%2F04%2F14%2F%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%2F%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[思维导图-知识整理 百度脑图 自用前端：HTML Css JQuery JSP Ajax EL表达式 JSTLJava：Java基础 MVC MVC案例 Servlet 学生管理系统数据交互：JDBC JDBC案例 数据库 数据库连接池 XML DBUtils MySQL 事务网络:HTTPLinux:Linux框架:SpringMVC Spring MyBatis Hibernate数据处理:Hadoop小程序:小程序 小程序开发]]></content>
      <categories>
        <category>思维导图</category>
      </categories>
      <tags>
        <tag>思维导图</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记第一个博客]]></title>
    <url>%2F2019%2F04%2F14%2F%E8%AE%B0%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[Hexo还是很棒的，非常漂亮方便，有了自己搭建的博客，就有更新博客的理由啦 哈哈哈 赶紧把我本地的笔记全部传上来 放着看还是很有成就感的 不错 有空再上来把我的未命名笔记们更新一遍吧 nice~]]></content>
  </entry>
  <entry>
    <title><![CDATA[秒杀系统项目总结（未完结）]]></title>
    <url>%2F2019%2F04%2F05%2F%E9%A1%B9%E7%9B%AE%2F%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[秒杀系统项目总结项目结构 seckill src - 源目录 main - 主目录 java - 项目中Java代码 resources - 资源文件 classpath目录 存放相应的资源文件 项目所需的配置文件一般放在这里读取 例如spring-dao, spring-service, spring-web 和jdbc的配置文件 以及mybatis的配置文件 mapper映射等等 mapper - spring target pom.xml POM, Project Object Model, 项目对象模型, Maven项目中的文件, 使用XML表示, 作用类似ant中的build.xml文件, 功能更强大 该文件用于管理: 源代码, 配置文件, 开发者的信息和角色, 问题追踪系统, 组织信息, 项目授权, 项目的url, 项目的依赖关系等等 Spring IOC Invension of Control 控制反转]]></content>
      <categories>
        <category>项目</category>
        <category>秒杀系统</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019.3.20 问题集]]></title>
    <url>%2F2019%2F03%2F20%2F%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%2F2019.3.20%20%E9%97%AE%E9%A2%98%E9%9B%86%2F</url>
    <content type="text"><![CDATA[2019.3.20 问题集1. 面向对象和面向过程的区别面向过程优点： 性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、Linux/Unix等一般采用面向过程开发，性能是最重要的因素。 缺点： 没有面向对象易维护、易复用、易扩展 面向对象优点： 易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统更加灵活、更加易于维护 缺点： 性能比面向过程低 2. Java 语言有哪些特点 简单易学； 面向对象（封装，继承，多态）； 平台无关性（ Java 虚拟机实现平台无关性）； 可靠性； 安全性； 支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）； 支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）； 编译与解释并存； 3. 关于 JVM JDK 和 JRE 最详细通俗的解答JVMJava虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。 什么是字节码?采用字节码的好处是什么? 在 Java 中，JVM可以理解的代码就叫做字节码（即扩展名为 .class 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不专对一种特定的机器，因此，Java程序无须重新编译便可在多种不同的计算机上运行。 Java 程序从源代码到运行一般有下面3步： 我们需要格外注意的是 .class-&gt;机器码 这一步。在这一步 jvm 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的，也就是所谓的热点代码，所以后面引进了 JIT 编译器，JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 Java 是编译与解释共存的语言。 HotSpot采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是JIT所需要编译的部分。JVM会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快。JDK 9引入了一种新的编译模式AOT(Ahead of Time Compilation)，它是直接将字节码编译成机器码，这样就避免了JIT预热等各方面的开销。JDK支持分层编译和AOT协作使用。但是 ，AOT 编译器的编译质量是肯定比不上 JIT 编译器的。 总结：Java虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。 JDK 和 JREJDK是Java Development Kit，它是功能齐全的Java SDK。它拥有JRE所拥有的一切，还有编译器（javac）和工具（如javadoc和jdb）。它能够创建和编译程序。 JRE 是 Java运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java虚拟机（JVM），Java类库，java命令和其他的一些基础构件。但是，它不能用于创建新程序。 如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。如果你需要进行一些 Java 编程方面的工作，那么你就需要安装JDK了。但是，这不是绝对的。有时，即使您不打算在计算机上进行任何Java开发，仍然需要安装JDK。例如，如果要使用JSP部署Web应用程序，那么从技术上讲，您只是在应用程序服务器中运行Java程序。那你为什么需要JDK呢？因为应用程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译 servlet。 4. Oracle JDK 和 OpenJDK 的对比可能在看这个问题之前很多人和我一样并没有接触和使用过 OpenJDK 。那么Oracle和OpenJDK之间是否存在重大差异？下面通过我通过我收集到一些资料对你解答这个被很多人忽视的问题。 对于Java 7，没什么关键的地方。OpenJDK项目主要基于Sun捐赠的HotSpot源代码。此外，OpenJDK被选为Java 7的参考实现，由Oracle工程师维护。关于JVM，JDK，JRE和OpenJDK之间的区别，Oracle博客帖子在2012年有一个更详细的答案： 问：OpenJDK存储库中的源代码与用于构建Oracle JDK的代码之间有什么区别？ 答：非常接近 - 我们的Oracle JDK版本构建过程基于OpenJDK 7构建，只添加了几个部分，例如部署代码，其中包括Oracle的Java插件和Java WebStart的实现，以及一些封闭的源代码派对组件，如图形光栅化器，一些开源的第三方组件，如Rhino，以及一些零碎的东西，如附加文档或第三方字体。展望未来，我们的目的是开源Oracle JDK的所有部分，除了我们考虑商业功能的部分。 总结： Oracle JDK版本将每三年发布一次，而OpenJDK版本每三个月发布一次； OpenJDK 是一个参考模型并且是完全开源的，而Oracle JDK是OpenJDK的一个实现，并不是完全开源的； Oracle JDK 比 OpenJDK 更稳定。OpenJDK和Oracle JDK的代码几乎相同，但Oracle JDK有更多的类和一些错误修复。因此，如果您想开发企业/商业软件，我建议您选择Oracle JDK，因为它经过了彻底的测试和稳定。某些情况下，有些人提到在使用OpenJDK 可能会遇到了许多应用程序崩溃的问题，但是，只需切换到Oracle JDK就可以解决问题； 在响应性和JVM性能方面，Oracle JDK与OpenJDK相比提供了更好的性能； Oracle JDK不会为即将发布的版本提供长期支持，用户每次都必须通过更新到最新版本获得支持来获取最新版本； Oracle JDK根据二进制代码许可协议获得许可，而OpenJDK根据GPL v2许可获得许可。 5. Java和C++的区别我知道很多人没学过 C++，但是面试官就是没事喜欢拿咱们 Java 和 C++ 比呀！没办法！！！就算没学过C++，也要记下来！ 都是面向对象的语言，都支持封装、继承和多态 Java 不提供指针来直接访问内存，程序内存更加安全 Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。 Java 有自动内存管理机制，不需要程序员手动释放无用内存 6. 什么是 Java 程序的主类 应用程序和小程序的主类有何不同一个程序中可以有多个类，但只能有一个类是主类。在 Java 应用程序中，这个主类是指包含 main（）方法的类。而在 Java 小程序中，这个主类是一个继承自系统类 JApplet 或 Applet 的子类。应用程序的主类不一定要求是 public 类，但小程序的主类要求必须是 public 类。主类是 Java 程序执行的入口点。 7. Java 应用程序与小程序之间有那些差别简单说应用程序是从主线程启动(也就是 main() 方法)。applet 小程序没有main方法，主要是嵌在浏览器页面上运行(调用init()线程或者run()来启动)，嵌入浏览器这点跟 flash 的小游戏类似。 8. 字符型常量和字符串常量的区别 形式上: 字符常量是单引号引起的一个字符 字符串常量是双引号引起的若干个字符 含义上: 字符常量相当于一个整形值( ASCII 值),可以参加表达式运算 字符串常量代表一个地址值(该字符串在内存中存放位置) 占内存大小 字符常量只占2个字节 字符串常量占若干个字节(至少一个字符结束标志) (注意： char在Java中占两个字节) java编程思想第四版：2.2.2节]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>学习日记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[求1+2+3+...+n]]></title>
    <url>%2F2019%2F03%2F20%2F%E7%AE%97%E6%B3%95%2F%E6%B1%821%2B2%2B3%2B...%2Bn%2F</url>
    <content type="text"><![CDATA[求1+2+3+…+n 求1+2+3+…+n，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。 1 递归加到0之后 如何停止程序 ​ 通过短路运算符&amp;&amp;使sum停止累加 12345678// 通过运算符 以及一些判断public class Solution &#123; public int Sum_Solution(int n) &#123; int sum = n; boolean temp = n &gt; 0 &amp;&amp; (sum += Sum_Solution(n - 1)) &gt; 0; return sum; &#125;&#125; 2 使用try catch制造在n=0时可能有的异常, 让异常来终端程序执行 12345678910111213// 0不能为分母public class Solution &#123; public int Sum_Solution(int n) &#123; int sum = 0; try&#123; int i = 1 % n; sum = n + Sum_Solution(n - 1); &#125;catch(Exception e)&#123; e.printStackTrace(); &#125; return sum; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1 二维数组中的查找]]></title>
    <url>%2F2019%2F03%2F20%2F%E7%AE%97%E6%B3%95%2F1%20%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[1 二维数组中的查找 在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 1 暴力(n^2)12345678910111213// 暴力public class Solution &#123; public boolean Find(int target, int [][] array) &#123; for(int i = 0; i &lt; array.length; i ++)&#123; for(int j = 0; j &lt; array[i].length; j ++)&#123; if(array[i][j] == target)&#123; return true; &#125; &#125; &#125; return false; &#125;&#125; 2 二分法(nlogn)1234567891011121314151617181920212223242526272829// 二分查找public class Solution &#123; public boolean Find(int target, int [][] array) &#123; for(int i = 0; i &lt; array.length; i ++)&#123; int left = 0; int right = array[i].length - 1; // 临界条件 左边永远要小于等于右边 while(left &lt;= right)&#123; // 取中位数索引 int mid = (left + right) / 2; // 若中位数大于target 说明target位于中位数左边 if(array[i][mid] &gt; target)&#123; // 令left等于mid-1 因为中位数不等于target right = mid - 1; &#125; // 若中位数小于target 说明target位于中位数右边 else if(array[i][mid] &lt; target)&#123; // right等于mid + 1 因为中位数不等于target left = mid + 1; &#125; // 等于的话 就找到啦 else&#123; return true; &#125; &#125; &#125; return false; &#125;&#125; 3 从左下角或者右上角开始找(n+m)12345678910111213141516171819202122232425262728293031// 从右上角找 必须在等长的情况下 左下角也行public class Solution &#123; public boolean Find(int target, int [][] array) &#123; //从右上角开始找 int rowCount = array.length; int colCount = array[0].length; int row = 0; int col = colCount - 1; // 条件 数组不越界 while(row &lt;= rowCount - 1 &amp;&amp; col &gt;= 0)&#123; // 当前的遍历值找到了 返回 if(target == array[row][col])&#123; return true; &#125; // 当前遍历值比target要小 那剩下左边的的一行都比target要小 if(array[row][col] &lt; target)&#123; // 往下移 row ++; continue; &#125; // 当前遍历值比target要大 那剩下的下方的都比它要大 if(array[row][col] &gt; target)&#123; // 往左移 col --; continue; &#125; &#125; return false; &#125;&#125;]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
      <tags>
        <tag>Algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019.3.19 问题集]]></title>
    <url>%2F2019%2F03%2F19%2F%E5%AD%A6%E4%B9%A0%E6%97%A5%E8%AE%B0%2F2019.3.19%20%E9%97%AE%E9%A2%98%E9%9B%86%2F</url>
    <content type="text"><![CDATA[2019.3.19 问题集Spring的问题 Bean 作用域Scope Spring中Bean有五种scope，singleton prototype request session globalSession singleton为默认值，IOC容器中仅存在一个Bean实例，Bean都以单例模式存在 prototype，在每次请求获取Bean的时候，都会创建一个新的实例，它在容器初始化的时候不会创建实例，采用的是延迟加载的形式注入Bean，当你使用**的时候，才会进行实例化，每次实例化获取的对象都不是同一个 就像BeanFactory的实例化模式 实例不唯一**,容器在初始化prototype作用域的Bean时,会将该Bean的生命周期全权交给客户端管理 request，在每一次http请求时会创建一个实例，该实例仅在当前http request有效 session，在每一次http**请求时会创建一个实例，该实例仅在当前http session**有效 globalSession，全局Session，供不同的portlet共享，portlet好像是类似于servlet的Web组件 Spring Bean的生命周期 Bean容器在配置文件中找到Bean的定义 Bean容器利用Java Reflection api来创建一个Bean的实例 Bean容器通过调用相应Loader方法来一一设置Bean，例如set名字、set属性、类加载器等等 当定义了初始化init-method属性时，执行指定方法 执行加载该Bean的对象的指定方法，就是加载这个Bean的对象，必定是要通过实例化该Bean进行某些过程性的操作 当定义了销毁destroy-method时,执行指定方法 执行destroy()方法,销毁Bean Bean的实例化方式 无参构造 静态工厂实例化 实例工厂实例化 Spring的属性注入 构造方法属性注入 Set方法属性注入 P名称空间的属性注入 引入p名称空间完成属性注入(2.5之后) SPEL spring expression language Spring的表达式语言(3.0之后) 就跟EL表达式的注入方式一样 集合类属性注入 IOC介绍 简单的IOC实现 加载XML配置文件, 遍历其中的标签 获取标签中的id和class属性, 加载class属性对应的类, 创建Bean 遍历标签, 获取标签的属性值, 将属性值填充到Bean对象中 将Bean注册到Bean容器中 原理 将对象的创建权反转交给Spring Invension of Controll(控制反转) 产生原因 - 解耦 常规的impl实现类, 使接口与实现类有耦合, 为了更好的满足程序设计原则 - 开闭原则, 对外扩展开放, 对内修改关闭 在尽量不修改源程序的代码的情况下对程序进行拓展 为了解耦, 引入工厂模式, 创建一个工厂类将所有的实现类整合起来, 这样一来, 想要对程序进行接口与实现类之前没有耦合, 有耦合的变成了工厂和实现类 依赖注入DI 在IOC的环境下,Spring管理Bean的时候将Bean的依赖属性注入到Bean中 AOP 定义 面向切面编程 Aspect Oriented Programming 简单的AOP实现 JDK动态代理 - 只能对实现接口的类产生代理 - invoke Cglib动态代理 - 采用Javassist第三方代理技术, 没有实现类的接口也可以产生代理对象 - intercept AOP技术优势在于: 将核心关注点与横切关注点完全隔离 Spring AOP的面向切面的通知 前置通知: Before 后置通知: After 返回通知: After-returning 异常通知: After-throwing 环绕通知: Around 工厂模式 工厂类 BeanFactory是Spring的心脏，采用延迟加载的形式注入Bean，当使用某个Bean的时候，才会对该Bean进行实例化 ApplicationContext是BeanFactory派生的接口，在初始化的时候就会一次性创建所有的Bean BeanFactory需要在加载实例化的时候，才能发现Spring中的一些Bean配置问题，而ApplicationContext在初始化自身时就会进行检验 ApplicationContext的不足就是占用内存空间，且Bean较多的时候，程序启动较慢 ApplicationContext通过预加载实例Bean，使你不用等待实例的创建，从这个角度来讲可能比BeanFactory效率要更高 Application有两个实现类 ClassPathXmlApplicationContext 加载类路径下的配置文件 FileSystemXmlApplicationContext 加载文件系统下的配置文件]]></content>
      <categories>
        <category>学习日记</category>
      </categories>
      <tags>
        <tag>学习日记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库分析]]></title>
    <url>%2F2018%2F12%2F30%2F%E9%A1%B9%E7%9B%AE%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[1 创建数据库 2 使用数据库 3 创建表 秒杀库存表 ​ 商品库存id seckill_id ​ 商品名称 name ​ 库存数量 number 秒杀开启时间 start_time ​ 秒杀结束时间 end_time ​ 创建时间 create_time ​ 主键 seckill_id ​ 索引 start_time end_time create_time ​ engine InnoDB ​ 自增从1000开始 ​ 默认编码utf8 ​ 注释 秒杀库存表 秒杀成功明细表 ​ 秒杀商品id seckill_id ​ 用户手机号 phone ​ 状态标识 state -1:无效 0:成功 1 重复秒杀 ​ 创建时间 create_time ​ 联合主键 seckill_id phone ​ 索引 create_time ​ 引擎 InnoDB ​ 编码格式 utf8 ​ 注释 秒杀成功明细表 4 初始化数据 ​ insert ​ name ​ number ​ start_time ​ end_time]]></content>
      <categories>
        <category>项目</category>
        <category>秒杀系统</category>
      </categories>
      <tags>
        <tag>项目</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[14 Maven-软件项目管理工具]]></title>
    <url>%2F2018%2F11%2F20%2FMaven%2F14.Maven-%E8%BD%AF%E4%BB%B6%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[Maven-软件项目管理工具 目录文件夹介绍 bin目录包含mvn的运行脚本 m2.conf-配置文件 boot目录包含一个类加载器的框架 conf目录包含一些配置文件 lib目录包含自身的一些类库 配置环境变量 M2_HOME对应maven目录 Path配置bin目录 测试：shell中 mvn -v 查看版本 Pom.xml配置 groupId是项目的包名 artifactID是项目模块名，即项目名 version是版本好，初始我们会命名为1.0-SNAPSHOT SNAPSHOT为快照版本的意思，在一般开发的时候，我们可以频繁的发布SNAPSHOT版本，以便让其他项目能实时的使用到最新的功能做联调；当版本趋于稳定时，再发一个正式版本，供正式使用 在做正式发布的时候，确保当前项目的依赖项中不包含对任何SNAPSHOT版本的依赖，保证正式版本的稳定性 Maven约定好的目录结构 src main java package test java package resources 常见命令 compile 编译 test 测试 package 打包 clean 删除target maven所生成的目标文件 install 安装jar包到本地仓库中 archetype插件 用于创建符合maven规定的目录骨架 快速创建maven骨架 archetype:generate 按照提示进行选择 archetype:generate -DgroupID=组织名，公司网址的反写+项目名 ​ -DartifactId=项目名-模块名 ​ -Dversion=版本号 ​ -Dpackage=代码所存在的包名 maven中的坐标和仓库 groupId和artifactId还有version就是坐标 仓库 本地仓库 远程仓库 中央仓库-全球默认仓库 镜像仓库-国内的镜像仓库 解决无法访问外网问题 更改仓库位置 conf.xml改变localReposities Maven插件安装 完整的项目构建过程 清理 编译 单元测试 针对程序模块（软件设计的最小单元）来进行正确性检验的测试工作。程序单元是应用和最小的可测试部件，在编写程序时可能要进行很多次单元测试，以证实程序达到软件规格书要求的工作目标 打包 集成测试 又称组装测试，即对程序模块采用一次性或增值方式组装起来，对系统的接口进行正确性的检验 验证 功能没问题了，我们需要验证结果的正确性 部署 maven生命周期 clean 清理项目 pre-clean 执行清理前的工作 clean 清理上一次构建生成的所有文件 post-clean 执行清理后的文件 default 构建项目-核心 compile test package install site 生成项目站点 pre-site 在生成项目站点前要完成的工作 site 生成项目的站点文档 post-site 在生成项目站点后要完成的工作 site-deploy 发布生成的站点到服务器是上 plugins与dependencies的区别 dependency：编译/运行时需要的，运行时开发都需要用到的jar包，比如项目中需要一个Json的jar包，就需要添加一个依赖，这个依赖在项目运行时也需要，因此在项目打包时需要把这些依赖也打包进项目里 plugin：编译时需要，在项目开发的时候需要，在项目运行时不需要，因此在项目开发完成后不需要把插件打包进项目中，比如有个可以在编译时需要某些调节参数的插件，编译结束后就没用了，所以项目打包时并不需要把插件加进去 pom.xml解析 坐标信息-（前三必要） groupId 反写公司网址+项目名 artifactId 项目名+模块名 version 版本号 第一位-大版本号 第二位-分支版本号 第三位-小版本号 0.0.1 snapshot-快照版本 alpha-内部测试 第一版本 内测 beta-公测 第二版本 公测 release-稳定 稳定版 GA(General Availability)-正式发布 packaging-项目描述名 name-项目描述名 url-项目地址 description-项目描述 如何指定依赖 指定坐标信息 指定范围-scope 设置依赖是否可选-默认为false 排除依赖传递列表-exclusions、exclusion 依赖管理-dependencyManagement build-构建 plugins parent-子模块对父模块的继承 modules-多个模块 依赖范围-scope compile（编译范围）-默认的范围，编译测试运行都有效 provided（已提供范围）-在编译和测试时有效（打包的时候不会被包进去，别的web container会提供） runtime（运行时范围）-在测试和运行时有效 test（测试范围）-只在测试时有效 system（系统范围）-与本机系统相关联，可移植性差 import-导入的范围，它只是用在dependencyManagement中表示从其他的pom中导入dependency的配置 maven依赖传递-dependencys 将子依赖包clean后install打包后到本地仓库 后 才可进行 依赖传递 排除依赖-exclusions 依赖冲突 1 短路优先-优先解析路径短的版本 2 先声明先优先-同长度路径情况 聚合-modules 如果我们想要一次构建两个或多个项目，而不是到两到三个模块下分别执行mvn命令，就会用到聚合 继承-denpendencyManagement 解决重复问题 设置父类依赖 denpendencyManagement 使用该标签 该标签中的依赖不会在该项目中运行 子类继承依赖 parent标签 继承父类依赖 使用maven构建web项目 构建的是 webapp 为什么springboot是quickstart 添加servlet依赖]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[13 Ajax&Jquery]]></title>
    <url>%2F2018%2F11%2F19%2F%E5%89%8D%E7%AB%AF%2F13.Ajax%20Jquery%2F</url>
    <content type="text"><![CDATA[Ajax &amp; JqueryAjax 是什么? “Asynchronous Javascript And XML”（异步JavaScript和XML）， 并不是新的技术，只是把原有的技术，整合到一起而已。 1.使用CSS和XHTML来表示。 2. 使用DOM模型来交互和动态显示。 3.使用XMLHttpRequest来和服务器进行异步通信。 4.使用javascript来绑定和调用。 有什么用? 咱们的网页如果想要刷新局部内容。 那么需要重新载入整个网页。用户体验不是很好。 就是为了解决局部刷新的问题。 保持其他部分不动，只刷新某些地方。 数据请求 Get1.创建对象 function ajaxFunction(){ var xmlHttp; try{ // Firefox, Opera 8.0+, Safari xmlHttp=new XMLHttpRequest(); } catch (e){ try{// Internet Explorer xmlHttp=new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;); } catch (e){ try{ xmlHttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;); } catch (e){} } } return xmlHttp; } 2. 发送请求 //执行get请求 function get() { //1. 创建xmlhttprequest 对象 var request = ajaxFunction(); //2. 发送请求。 // http://localhost:8080/day16/demo01.jsp //http://localhost:8080/day16/DemoServlet01 /* 参数一： 请求类型 GET or POST 参数二： 请求的路径 参数三： 是否异步， true or false */ request.open(&quot;GET&quot; ,&quot;/day16/DemoServlet01&quot; ,true ); request.send(); } 如果发送请求的同时，还想获取数据，那么代码如下 //执行get请求 function get() { //1. 创建xmlhttprequest 对象 var request = ajaxFunction(); //2. 发送请求 request.open(&quot;GET&quot; ,&quot;/day16/DemoServlet01?name=aa&amp;age=18&quot; ,true ); //3. 获取响应数据 注册监听的意思。 一会准备的状态发生了改变，那么就执行 = 号右边的方法 request.onreadystatechange = function(){ //前半段表示 已经能够正常处理。 再判断状态码是否是200 if(request.readyState == 4 &amp;&amp; request.status == 200){ //弹出响应的信息 alert(request.responseText); } } request.send(); } 数据请求 Post​ //1. 创建对象 function ajaxFunction(){ var xmlHttp; try{ // Firefox, Opera 8.0+, Safari xmlHttp=new XMLHttpRequest(); } catch (e){ try{// Internet Explorer xmlHttp=new ActiveXObject("Msxml2.XMLHTTP"); } catch (e){ try{ xmlHttp=new ActiveXObject("Microsoft.XMLHTTP"); } catch (e){} } } return xmlHttp; } function post() { //1. 创建对象 var request = ajaxFunction(); //2. 发送请求 request.open( "POST", "/day16/DemoServlet01", true ); //如果不带数据，写这行就可以了 //request.send(); //如果想带数据，就写下面的两行 //如果使用的是post方式带数据，那么 这里要添加头， 说明提交的数据类型是一个经过url编码的form表单数据 request.setRequestHeader("Content-type","application/x-www-form-urlencoded"); //带数据过去 ， 在send方法里面写表单数据。 request.send("name=aobama&age=19"); } 需要获取数据 function post() { //1. 创建对象 var request = ajaxFunction(); //2. 发送请求 request.open( &quot;POST&quot;, &quot;/day16/DemoServlet01&quot;, true ); //想获取服务器传送过来的数据， 加一个状态的监听。 request.onreadystatechange=function(){ if(request.readyState==4 &amp;&amp; request.status == 200){ alert(&quot;post：&quot;+request.responseText); } } //如果使用的是post方式带数据，那么 这里要添加头， 说明提交的数据类型是一个经过url编码的form表单数据 request.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;); //带数据过去 ， 在send方法里面写表单数据。 request.send(&quot;name=aobama&amp;age=19&quot;); } 校验用户名是否可用1. 搭建环境 页面准备 &lt;body&gt; &lt;table border=&quot;1&quot; width=&quot;500&quot;&gt; &lt;tr&gt; &lt;td&gt;用户名:&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; onblur=&quot;checkUserName()&quot;&gt;&lt;span id=&quot;span01&quot;&gt;&lt;/span&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;邮箱&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;简介&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot;&gt;&lt;input type=&quot;submit&quot; value=&quot;注册&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 数据库准备 ###2. Servlet代码 protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { try { request.setCharacterEncoding(&quot;UTF-8&quot;); //1. 检测是否存在 String name = request.getParameter(&quot;name&quot;); System.out.println(&quot;name=&quot;+name); UserDao dao = new UserDaomImpl(); boolean isExist = dao.checkUserName(name); //2. 通知页面，到底有还是没有。 if(isExist){ response.getWriter().println(1); //存在用户名 }else{ response.getWriter().println(2); //不存在该用户名 } } catch (SQLException e) { e.printStackTrace(); } } 3. Dao代码public class UserDaomImpl implements UserDao{ @Override public boolean checkUserName(String username) throws SQLException { QueryRunner runner = new QueryRunner(JDBCUtil02.getDataSource()); String sql = &quot;select count(*) from t_user where username =?&quot;; runner.query(sql, new ScalarHandler(), username); Long result = (Long) runner.query(sql, new ScalarHandler(), username); return result &gt; 0 ; } } ###jsp页面显示 ​​ function checkUserName() { //获取输入框的值 document 整个网页 var name = document.getElementById(&quot;name&quot;).value; // value value() val val() //1. 创建对象 var request = ajaxFunction(); //2. 发送请求 request.open(&quot;POST&quot; ,&quot;/day16/CheckUserNameServlet&quot; , true ); //注册状态改变监听，获取服务器传送过来的数据 request.onreadystatechange = function(){ if(request.readyState == 4 &amp;&amp; request.status == 200){ //alert(request.responseText); var data = request.responseText; if(data == 1){ //alert(&quot;用户名已存在&quot;); document.getElementById(&quot;span01&quot;).innerHTML = &quot;&lt;font color=&apos;red&apos;&gt;用户名已存在!&lt;/font&gt;&quot;; }else{ document.getElementById(&quot;span01&quot;).innerHTML = &quot;&lt;font color=&apos;green&apos;&gt;用户名可用!&lt;/font&gt;&quot;; //alert(&quot;用户名未存在&quot;); } } } request.setRequestHeader(&quot;Content-type&quot;,&quot;application/x-www-form-urlencoded&quot;); request.send(&quot;name=&quot;+name); } JQuery 是什么? javascript 的代码框架。 有什么用? 简化代码，提高效率。 核心 write less do more , 写得更少，做的更多。 ###load &lt;a href=&quot;&quot; onclick=&quot;load()&quot;&gt;使用JQuery执行load方法&lt;/a&gt; 有两次刷新， 先走 onClick的方法，取到数据回来之后，赋值显示。 接着 走 href=&quot;&quot;的路径，但是这个属性没有给值，所以会把当前的页面重新再刷新一次。所以导致看不见值。 //找到这个元素， 去执行加载的动作， 加载/day16/DemoServlet02 ， 得到的数据，赋值显示 $(&quot;#aaa&quot;).load(&quot;/day16/DemoServlet02&quot; , function(responseText , statusTXT , xhr) { //找到id为text01的元素， 设置它的value属性值为 responseText 对应的值 $(&quot;#aaa&quot;).val(responseText); }); url 规定要将请求发送到哪个 URL。 data 可选。规定连同请求发送到服务器的数据。 function(response,status,xhr) 可选。规定当请求完成时运行的函数。 额外的参数： response - 包含来自请求的结果数据 status - 包含请求的状态（&quot;success&quot;, &quot;notmodified&quot;, &quot;error&quot;, &quot;timeout&quot; 或 &quot;parsererror&quot;） xhr - 包含 XMLHttpRequest 对象 Get$.get(&quot;/day16/DemoServlet02&quot; , function(data ,status) { $(&quot;#div01&quot;).text(data); }); 赋值显示 val(“aa”); 只能放那些标签带有value属性 html(“aa”); —写html代码 text(“aa”); 其实没有什么区别，如果想针对这分数据做html样式处理，那么只能用html() load &amp; get load $(&quot;#元素id&quot;).load(url地址); $(&quot;#div1&quot;).load(serlvet); ---&gt; 使用的get请求，回来赋值的时候， 使用text（）;去赋值 get 语法格式 ： $.get(URL,callback); 使用案例： $.get(&quot;/day16/DemoServlet02&quot; , function(data ,status) { $(&quot;#div01&quot;).text(data); }); post 语法格式：$.post(URL,data,callback); function post() { $.post(&quot;/day16/DemoServlet02&quot;, {name:&quot;zhangsan&quot;,age:18},function(data,status) { //想要放数据到div里面去。 --- 找到div $(&quot;#div01&quot;).html(data); }); } ###使用JQuery去实现校验用户名 function checkUserName() { //1. 获取输入框的内容 var name = $(&quot;#name&quot;).val(); //2. 发送请求 $.post(&quot;/day16/CheckUserNameServlet&quot; , {name:name} , function(data , status){ //alert(data); if(data == 1){//用户名存在 //alert(&quot;用户名存在&quot;); $(&quot;#span01&quot;).html(&quot;&lt;font color=&apos;red&apos;&gt;用户名已被注册&lt;/font&gt;&quot;); }else{ //alert(&quot;用户名可用&quot;); $(&quot;#span01&quot;).html(&quot;&lt;font color=&apos;green&apos;&gt;用户名可以使用&lt;/font&gt;&quot;); } } ); //3. 输出响应的数据到页面上。 } 实现百度搜索提示搭建环境 定义首页 &lt;body&gt; &lt;center&gt; &lt;h2&gt;黑马&lt;/h2&gt; &lt;input type=&quot;text&quot; name=&quot;word&quot; id=&quot;word&quot; style=&quot;width: 600px ; height: 50px ;font-size: 20px;&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;黑马一下&quot; style=&quot;height: 55px ; width: 100px ; &quot;&gt; &lt;div id=&quot;div01&quot; style=&quot;position:relative; left : -54px; width: 600px; height: 200px ; border: 1px solid blue; display: none&quot;&gt;&lt;/div&gt; &lt;/center&gt; &lt;/body&gt; 定义数据库 捕获键盘弹起$(function(){​ $(“#word”).keyup(function() {​ alert(“键盘弹起了..”);​ })}); JS请求$(function(){ $(&quot;#word&quot;).keyup(function() { //2。 获取输入框的值 //var word = $(&quot;#word&quot;).val(); //this 对应就是执行这个方法的那个对象， $(&quot;#word&quot;) var word = $(this).val(); if(word == &quot;&quot;){ $(&quot;#div01&quot;).hide(); }else{ //3. 请求数据。 $.post(&quot;find&quot;,{word:word} ,function(data , status){ //alert(data); $(&quot;#div01&quot;).show(); $(&quot;#div01&quot;).html(data); }); } }) }); Servlet代码 protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { request.setCharacterEncoding(&quot;utf-8&quot;); try { //1. 先获取参数 String word = request.getParameter(&quot;word&quot;); System.out.println(&quot;word=&quot;+word); //2. 让dao执行查询 WordsDao dao = new WordsDaoImpl(); List&lt;WordBean&gt; list = dao.findWords(word); for (WordBean wordBean : list) { System.out.println(&quot;===&quot;+wordBean.toString()); } request.setAttribute(&quot;list&quot;, list); //3. 返回数据 response.setContentType(&quot;text/html;charset=utf-8&quot;); //response.getWriter().write(&quot;数据是：&quot;); request.getRequestDispatcher(&quot;list.jsp&quot;).forward(request, response); } catch (SQLException e) { e.printStackTrace(); } } list.jsp&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;%@ taglib uri=&quot;http://java.sun.com/jsp/jstl/core&quot; prefix=&quot;c&quot;%&gt; ​​ ​ &lt;c:forEach items=”${list }” var=”wordBean”&gt;​ ​ ${wordBean.words}​ ​ &lt;/c:forEach&gt;​ 使用JQuery实现 省市联动环境准备 准备数据库 2 。 准备页面 &lt;script type=&quot;text/javascript&quot; src=&quot;js/jquery-1.11.3.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/city.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; 省份: &lt;select name=&quot;province&quot; id =&quot;province&quot;&gt; &lt;option value=&quot;&quot; &gt;-请选择 - &lt;option value=&quot;1&quot; &gt;广东 &lt;option value=&quot;2&quot; &gt;湖南 &lt;option value=&quot;3&quot; &gt;湖北 &lt;option value=&quot;4&quot; &gt;四川 &lt;/select&gt; 城市: &lt;select name=&quot;city&quot; id=&quot;city&quot;&gt; &lt;option value=&quot;&quot; &gt;-请选择 - &lt;/select&gt; &lt;/body&gt; XStream的使用//3. 返回数据。手动拼 ---&gt; XStream 转化 bean对象成 xml XStream xStream = new XStream(); //想把id做成属性 xStream.useAttributeFor(CityBean.class, &quot;id&quot;); //设置别名 xStream.alias(&quot;city&quot;, CityBean.class); //转化一个对象成xml字符串 String xml = xStream.toXML(list); JS代码 $(function() { //1。找到省份的元素 $(&quot;#province&quot;).change(function() { //2. 一旦里面的值发生了改变，那么就去请求该省份的城市数据 //$(&quot;#province&quot;).varl(); var pid = $(this).val(); /*&lt;list&gt; &lt;city&gt; &lt;id&gt;1&lt;id&gt; &lt;pid&gt;1&lt;/pid&gt; &lt;cname&gt;深圳&lt;/cname&gt; &lt;/city&gt; &lt;city &gt; &lt;id&gt;2&lt;id&gt; &lt;pid&gt;1&lt;/pid&gt; &lt;cname&gt;东莞&lt;/cname&gt; &lt;/city&gt; &lt;/list&gt;*/ $.post( &quot;CityServlet&quot;,{pid:pid} ,function(data,status){ //alert(&quot;回来数据了:&quot;+data); //先清空以前的值： $(&quot;#city&quot;).html(&quot;&lt;option value=&apos;&apos; &gt;-请选择-&quot;) //遍历： //从data数据里面找出所有的city ， 然后遍历所有的city。 //遍历一个city，就执行一次function方法 $(data).find(&quot;city&quot;).each(function() { //遍历出来的每一个city，取它的孩子。 id , cname var id = $(this).children(&quot;id&quot;).text(); var cname = $(this).children(&quot;cname&quot;).text(); $(&quot;#city&quot;).append(&quot;&lt;option value=&apos;&quot;+id+&quot;&apos; &gt;&quot;+cname) }); } ); }); }); 服务器和客户端数据传输的方式 xml &lt;list&gt; &lt;city&gt; &lt;id&gt;1&lt;id&gt; &lt;pid&gt;1&lt;/pid&gt; &lt;cname&gt;深圳&lt;/cname&gt; &lt;/city&gt; &lt;city &gt; &lt;id&gt;2&lt;id&gt; &lt;pid&gt;1&lt;/pid&gt; &lt;cname&gt;东莞&lt;/cname&gt; &lt;/city&gt; &lt;/list&gt; json 阅读性更好 、 容量更小。 {“name”:”aaa” , “age”:19} 把javaBean 转化成 json数据 //3. 把list ---&gt; json数据 //JSONArray ---&gt; 变成数组 ， 集合 [] //JSONObject ---&gt; 变成简单的数据 { name : zhangsan , age:18} JSONArray jsonArray = JSONArray.fromObject(list); String json = jsonArray.toString(); 使用json格式数据显示省市联动效果​ serlvet代码： protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { try { //1. 获取参数 int pid = Integer.parseInt(request.getParameter(&quot;pid&quot;)); //2 找出所有的城市 CityDao dao = new CityDaoImpl(); List&lt;CityBean&gt; list = dao.findCity(pid); //3. 把list ---&gt; json数据 //JSONArray ---&gt; 变成数组 ， 集合 [] //JSONObject ---&gt; 变成简单的数据 { name : zhangsan , age:18} JSONArray jsonArray = JSONArray.fromObject(list); String json = jsonArray.toString(); response.setContentType(&quot;text/html;charset=utf-8&quot;); response.getWriter().write(json); } catch (SQLException e) { // TODO Auto-generated catch block e.printStackTrace(); }; } js代码 $(function() { //1。找到省份的元素 $(&quot;#province&quot;).change(function() { //2. 一旦里面的值发生了改变，那么就去请求该省份的城市数据 //$(&quot;#province&quot;).varl(); var pid = $(this).val(); /*[ { &quot;cname&quot;: &quot;深圳&quot;, &quot;id&quot;: 1, &quot;pid&quot;: 1 }, { &quot;cname&quot;: &quot;东莞&quot;, &quot;id&quot;: 2, &quot;pid&quot;: 1 } ... ]*/ $.post( &quot;CityServlet02&quot;,{pid:pid} ,function(data,status){ //先清空 $(&quot;#city&quot;).html(&quot;&lt;option value=&apos;&apos; &gt;-请选择-&quot;); //再遍历，追加 $(data).each(function(index , c) { $(&quot;#city&quot;).append(&quot;&lt;option value=&apos;&quot;+c.id+&quot;&apos; &gt;&quot;+c.cname) }); },&quot;json&quot; ); }); }); 总结Ajax发送get请求 发送post请求 都要求带数据 + 获取数据＋ 放置到元素上。 JQuery发送get请求 发送post请求 都要求带数据 + 获取数据＋ 放置到元素上。 --------------------------------------- 1. 服务器返回xml数据 2. 服务器返回json数据]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[12 MVC]]></title>
    <url>%2F2018%2F11%2F15%2FMVC%2F12.MVC%2F</url>
    <content type="text"><![CDATA[元数据Meata data 描述数据的数据 String sql , 描述这份sql字符串的数据叫做元数据 数据库元数据 DatabaseMetaData参数元数据 ParameterMetaData结果集元数据 ResultSetMetaData MVC设计模式JSP的开发模式 三层架构&amp;MVC练习 学生信息管理系统数据库准备CREATE DATABASE stus; USE stus; CREATE TABLE stu ( sid INT PRIMARY KEY AUTO_INCREMENT, sname VARCHAR (20), gender VARCHAR (5), phone VARCHAR (20), birthday DATE, hobby VARCHAR(50), info VARCHAR(200) ); 查询 先写一个JSP 页面， 里面放一个超链接 。 学生列表显示 写Servlet， 接收请求， 去调用 Service , 由service去调用dao 先写Dao , 做Dao实现。 public interface StudentDao { ​​ /** 查询所有学生 @return List */ List findAll() throws SQLException ; } public class StudentDaoImpl implements StudentDao { ​​ /*​ 查询所有学生​ @throws SQLException​ /​ @Override​ public List findAll() throws SQLException {​ QueryRunner runner = new QueryRunner(JDBCUtil02.getDataSource());​ return runner.query(“select * from stu”, new BeanListHandler(Student.class));​ }​​ } 再Service , 做Service的实现。 /** * 这是学生的业务处理规范 * @author xiaomi * */ public interface StudentService { /** * 查询所有学生 * @return List&lt;Student&gt; */ List&lt;Student&gt; findAll() throws SQLException ; } ------------------------------------------ /** * 这是学生业务实现 * @author xiaomi * */ public class StudentServiceImpl implements StudentService{ @Override public List&lt;Student&gt; findAll() throws SQLException { StudentDao dao = new StudentDaoImpl(); return dao.findAll(); } } 在servlet 存储数据，并且做出页面响应。 protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { ​ try { //1. 查询出来所有的学生 StudentService service = new StudentServiceImpl(); List&lt;Student&gt; list = service.findAll(); //2. 先把数据存储到作用域中 request.setAttribute(&quot;list&quot;, list); //3. 跳转页面 request.getRequestDispatcher(&quot;list.jsp&quot;).forward(request, response); } catch (SQLException e) { e.printStackTrace(); } } 在list.jsp上显示数据 EL + JSTL + 表格 增加 先跳转到增加的页面 ， 编写增加的页面 点击添加，提交数据到AddServlet . 处理数据。 调用service 调用dao, 完成数据持久化。 完成了这些存储工作后，需要跳转到列表页面。 这里不能直接跳转到列表页面，否则没有什么内容显示。 应该先跳转到查询所有学生信息的那个Servlet， 由那个Servlet再去跳转到列表页面。 爱好的value 值有多个。 request.getParameter(“hobby”);String[] hobby = request.getParameterValues(“hobby”) —&gt; String[]String value = Arrays.toString(hobby): // [爱好， 篮球， 足球] 删除 点击超链接，弹出一个询问是否删除的对话框，如果点击了确定，那么就真的删除。 &lt;a href=&quot;#&quot; onclick=&quot;doDelete(${stu.sid})&quot;&gt;删除&lt;/a&gt; ​ 让超链接，执行一个js方法 &lt;script type=&quot;text/javascript&quot;&gt; function doDelete(sid) { /* 如果这里弹出的对话框，用户点击的是确定，就马上去请求Servlet。 如何知道用户点击的是确定。 如何在js的方法中请求servlet。 */ var flag = confirm(&quot;是否确定删除?&quot;); if(flag){ //表明点了确定。 访问servlet。 在当前标签页上打开 超链接， //window.location.href=&quot;DeleteServlet?sid=&quot;+sid; location.href=&quot;DeleteServlet?sid=&quot;+sid; } } &lt;/script&gt; 在js访问里面判断点击的选项，然后跳转到servlet。 servlet收到了请求，然后去调用service ， service去调用dao 更新 点击列表上的更新， 先跳转到一个EditServlet 在这个Servlet里面，先根据ID 去查询这个学生的所有信息出来。 跳转到更新的页面。 ，然后在页面上显示数据 &lt;tr&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;&lt;input type=&quot;text&quot; name=&quot;sname&quot; value=&quot;${stu.sname }&quot;&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;性别&lt;/td&gt; &lt;td&gt; &lt;!-- 如果性别是男的， 可以在男的性别 input标签里面， 出现checked , 如果性别是男的， 可以在女的性别 input标签里面，出现checked --&gt; &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;男&quot; &lt;c:if test=&quot;${stu.gender == &apos;男&apos;}&quot;&gt;checked&lt;/c:if&gt;&gt;男 &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;女&quot; &lt;c:if test=&quot;${stu.gender == &apos;女&apos;}&quot;&gt;checked&lt;/c:if&gt;&gt;女 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;爱好&lt;/td&gt; &lt;td&gt; &lt;!-- 爱好： 篮球 ， 足球 ， 看书 因为爱好有很多个， 里面存在包含的关系 --&gt; &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;游泳&quot; &lt;c:if test=&quot;${fn:contains(stu.hobby,&apos;游泳&apos;) }&quot;&gt;checked&lt;/c:if&gt;&gt;游泳 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;篮球&quot; &lt;c:if test=&quot;${fn:contains(stu.hobby,&apos;篮球&apos;) }&quot;&gt;checked&lt;/c:if&gt;&gt;篮球 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;足球&quot; &lt;c:if test=&quot;${fn:contains(stu.hobby,&apos;足球&apos;) }&quot;&gt;checked&lt;/c:if&gt;&gt;足球 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;看书&quot; &lt;c:if test=&quot;${fn:contains(stu.hobby,&apos;看书&apos;) }&quot;&gt;checked&lt;/c:if&gt;&gt;看书 &lt;input type=&quot;checkbox&quot; name=&quot;hobby&quot; value=&quot;写字&quot; &lt;c:if test=&quot;${fn:contains(stu.hobby,&apos;写字&apos;) }&quot;&gt;checked&lt;/c:if&gt;&gt;写字 &lt;/td&gt; &lt;/tr&gt; 修改完毕后，提交数据到UpdateServlet 提交上来的数据是没有带id的，所以我们要手动创建一个隐藏的输入框， 在这里面给定id的值， 以便提交表单，带上id。 &lt;form method=&quot;post&quot; action=&quot;UpdateServlet&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;sid&quot; value=&quot;${stu.sid }&quot;&gt; ... &lt;/form&gt; 获取数据，调用service， 调用dao. 分页功能 物理分页 （真分页） 来数据库查询的时候，只查一页的数据就返回了。 优点 内存中的数据量不会太大 ​ 缺点：对数据库的访问频繁了一点。 SELECT * FROM stu LIMIT 5 OFFSET 2 逻辑分页 （假分页） 一口气把所有的数据全部查询出来，然后放置在内存中。 优点： 访问速度快。 缺点： 数据库量过大，内存溢出。 ​]]></content>
      <categories>
        <category>MVC设计模式</category>
      </categories>
      <tags>
        <tag>MVC设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[11 事务&数据库连接池&DBUtils]]></title>
    <url>%2F2018%2F11%2F05%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2F11.%E4%BA%8B%E5%8A%A1%20%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%20DBUtils%2F</url>
    <content type="text"><![CDATA[事务&amp;数据库连接池&amp;DBUtils事务 Transaction 其实指的一组操作，里面包含许多个单一的逻辑。只要有一个逻辑没有执行成功，那么都算失败。 所有的数据都回归到最初的状态(回滚) 为什么要有事务? 为了确保逻辑的成功。 例子： 银行的转账。 使用命令行方式演示事务。 开启事务 start transaction; 提交或者回滚事务 commit; 提交事务， 数据将会写到磁盘上的数据库 rollback ; 数据回滚，回到最初的状态。 关闭自动提交功能。 演示事务 使用代码方式演示事务 代码里面的事务，主要是针对连接来的。 通过conn.setAutoCommit（false ）来关闭自动提交的设置。 提交事务 conn.commit(); 回滚事务 conn.rollback(); @Test public void testTransaction(){ Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try { conn = JDBCUtil.getConn(); //连接，事务默认就是自动提交的。 关闭自动提交。 conn.setAutoCommit(false); String sql = &quot;update account set money = money - ? where id = ?&quot;; ps = conn.prepareStatement(sql); //扣钱， 扣ID为1 的100块钱 ps.setInt(1, 100); ps.setInt(2, 1); ps.executeUpdate(); ​​ int a = 10 /0 ;​​ //加钱， 给ID为2 加100块钱​ ps.setInt(1, -100);​ ps.setInt(2, 2);​ ps.executeUpdate();​​ //成功： 提交事务。​ conn.commit();​​ } catch (SQLException e) {​ try {​ //事变： 回滚事务​ conn.rollback();​ } catch (SQLException e1) {​ e1.printStackTrace();​ }​ e.printStackTrace();​​ }finally {​ JDBCUtil.release(conn, ps, rs);​ }​ } 事务的特性 原子性 指的是 事务中包含的逻辑，不可分割。 一致性 指的是 事务执行前后。数据完整性 隔离性 指的是 事务在执行期间不应该受到其他事务的影响 持久性 指的是 事务执行成功，那么数据应该持久保存到磁盘上。 事务的安全隐患 不考虑隔离级别设置，那么会出现以下问题。 读 脏读 不可重读读 幻读. * 脏读 &gt; 一个事务读到另外一个事务还未提交的数据 * 不可重复读 &gt; 一个事务读到了另外一个事务提交的数据 ，造成了前后两次查询结果不一致。 ## 读未提交 演示 设置A窗口的隔离级别为 读未提交 两个窗口都分别开启事务 写 丢失更新 ## 读已提交演示 设置A窗口的隔离级别为 读已提交 A B 两个窗口都开启事务， 在B窗口执行更新操作。 在A窗口执行的查询结果不一致。 一次是在B窗口提交事务之前，一次是在B窗口提交事务之后。 这个隔离级别能够屏蔽 脏读的现象， 但是引发了另一个问题 ，不可重复读。 可串行化 如果有一个连接的隔离级别设置为了串行化 ，那么谁先打开了事务， 谁就有了先执行的权利， 谁后打开事务，谁就只能得着，等前面的那个事务，提交或者回滚后，才能执行。 但是这种隔离级别一般比较少用。 容易造成性能上的问题。 效率比较低。 按效率划分，从高到低 读未提交 &gt; 读已提交 &gt; 可重复读 &gt; 可串行化 按拦截程度 ，从高到底 可串行化 &gt; 可重复读 &gt; 读已提交 &gt; 读未提交 事务总结需要掌握的 在代码里面会使用事务 conn.setAutoCommit(false); conn.commit(); conn.rollback(); 事务只是针对连接连接对象，如果再开一个连接对象，那么那是默认的提交。 事务是会自动提交的。 需要了解的## 安全隐患读 脏读 一个事务读到了另一个事务未提交的数据 不可重复读 一个事务读到了另一个事务已提交的数据，造成前后两次查询结果不一致 幻读 一个事务读到了另一个事务insert的数据 ，造成前后查询结果不一致 。 写 丢失更新。 ## 隔离级别读未提交 引发问题： 脏读 读已提交 解决： 脏读 ， 引发： 不可重复读 可重复读 解决： 脏读 、 不可重复读 ， 未解决： 幻读 可串行化 解决： 脏读、 不可重复读 、 幻读。 mySql 默认的隔离级别是 可重复读 Oracle 默认的隔离级别是 读已提交 丢失更新 解决丢失更新 悲观锁 可以在查询的时候，加入 for update 乐观锁 要求程序员自己控制。 数据库连接池 数据库的连接对象创建工作，比较消耗性能。 2.一开始现在内存中开辟一块空间（集合） ， 一开先往池子里面放置 多个连接对象。 后面需要连接的话，直接从池子里面去。不要去自己创建连接了。 使用完毕， 要记得归还连接。确保连接对象能循环利用。 自定义数据库连接池 代码实现 出现的问题： 需要额外记住 addBack方法 单例。 无法面向接口编程。 UserDao dao = new UserDaoImpl();dao.insert(); DataSource dataSource = new MyDataSource(); 因为接口里面没有定义addBack方法。 4. 怎么解决? 以addBack 为切入点。 解决自定义数据库连接池出现的问题。 由于多了一个addBack 方法，所以使用这个连接池的地方，需要额外记住这个方法，并且还不能面向接口编程。 我们打算修改接口中的那个close方法。 原来的Connection对象的close方法，是真的关闭连接。打算修改这个close方法，以后在调用close， 并不是真的关闭，而是归还连接对象。 如何扩展某一个方法? 原有的方法逻辑，不是我们想要的。 想修改自己的逻辑 直接改源码 无法实现。 继承， 必须得知道这个接口的具体实现是谁。 使用装饰者模式。 开源连接池## DBCP 导入jar文件 不使用配置文件： public void testDBCP01(){ ​​ Connection conn = null;​ PreparedStatement ps = null;​ try {​​ //1. 构建数据源对象​ BasicDataSource dataSource = new BasicDataSource();​ //连的是什么类型的数据库， 访问的是哪个数据库 ， 用户名， 密码。。​ //jdbc:mysql://localhost/bank 主协议：子协议 ://本地/数据库​ dataSource.setDriverClassName(“com.mysql.jdbc.Driver”);​ dataSource.setUrl(“jdbc:mysql://localhost/bank”);​ dataSource.setUsername(“root”);​ dataSource.setPassword(“root”); ​​ //2. 得到连接对象​ conn = dataSource.getConnection();​ String sql = “insert into account values(null , ? , ?)”;​ ps = conn.prepareStatement(sql);​ ps.setString(1, “admin”);​ ps.setInt(2, 1000);​​ ps.executeUpdate();​​ } catch (SQLException e) {​ e.printStackTrace();​ }finally {​ JDBCUtil.release(conn, ps);​ }​​ } 使用配置文件方式： Connection conn = null; PreparedStatement ps = null; try { BasicDataSourceFactory factory = new BasicDataSourceFactory(); Properties properties = new Properties(); InputStream is = new FileInputStream(&quot;src//dbcpconfig.properties&quot;); properties.load(is); DataSource dataSource = factory.createDataSource(properties); //2. 得到连接对象 conn = dataSource.getConnection(); String sql = &quot;insert into account values(null , ? , ?)&quot;; ps = conn.prepareStatement(sql); ps.setString(1, &quot;liangchaowei&quot;); ps.setInt(2, 100); ps.executeUpdate(); } catch (Exception e) { e.printStackTrace(); }finally { JDBCUtil.release(conn, ps); } ​ C3P0 拷贝jar文件 到 lib目录 不使用配置文件方式Connection conn = null; PreparedStatement ps = null; try { //1. 创建datasource ComboPooledDataSource dataSource = new ComboPooledDataSource(); //2. 设置连接数据的信息 dataSource.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;); //忘记了---&gt; 去以前的代码 ---&gt; jdbc的文档 dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost/bank&quot;); dataSource.setUser(&quot;root&quot;); dataSource.setPassword(&quot;root&quot;); //2. 得到连接对象 conn = dataSource.getConnection(); String sql = &quot;insert into account values(null , ? , ?)&quot;; ps = conn.prepareStatement(sql); ps.setString(1, &quot;admi234n&quot;); ps.setInt(2, 103200); ps.executeUpdate(); } catch (Exception e) { e.printStackTrace(); }finally { JDBCUtil.release(conn, ps); } 使用配置文件方式//默认会找 xml 中的 default-config 分支。 ComboPooledDataSource dataSource = new ComboPooledDataSource(); //2. 设置连接数据的信息 dataSource.setDriverClass(&quot;com.mysql.jdbc.Driver&quot;); //忘记了---&gt; 去以前的代码 ---&gt; jdbc的文档 dataSource.setJdbcUrl(&quot;jdbc:mysql://localhost/bank&quot;); dataSource.setUser(&quot;root&quot;); dataSource.setPassword(&quot;root&quot;); //2. 得到连接对象 conn = dataSource.getConnection(); String sql = &quot;insert into account values(null , ? , ?)&quot;; ps = conn.prepareStatement(sql); ps.setString(1, &quot;admi234n&quot;); ps.setInt(2, 103200); DBUtils增删改 //dbutils 只是帮我们简化了CRUD 的代码， 但是连接的创建以及获取工作。 不在他的考虑范围 QueryRunner queryRunner = new QueryRunner(new ComboPooledDataSource()); ​​ //增加​ //queryRunner.update(“insert into account values (null , ? , ? )”, “aa” ,1000);​​ //删除​ //queryRunner.update(“delete from account where id = ?”, 5);​​ //更新​ //queryRunner.update(“update account set money = ? where id = ?”, 10000000 , 6); 查询 直接new接口的匿名实现类 QueryRunner queryRunner = new QueryRunner(new ComboPooledDataSource()); Account account = queryRunner.query(&quot;select * from account where id = ?&quot;, new ResultSetHandler&lt;Account&gt;(){ @Override public Account handle(ResultSet rs) throws SQLException { Account account = new Account(); while(rs.next()){ String name = rs.getString(&quot;name&quot;); int money = rs.getInt(&quot;money&quot;); account.setName(name); account.setMoney(money); } return account; } }, 6); System.out.println(account.toString()); 直接使用框架已经写好的实现类。 * 查询单个对象 QueryRunner queryRunner = new QueryRunner(new ComboPooledDataSource()); //查询单个对象 Account account = queryRunner.query(&quot;select * from account where id = ?&quot;, new BeanHandler&lt;Account&gt;(Account.class), 8); ​​ 查询多个对象​​ QueryRunner queryRunner = new QueryRunner(new ComboPooledDataSource());​ List list = queryRunner.query(“select from account “,​ new BeanListHandler(Account.class)); ResultSetHandler 常用的实现类以下两个是使用频率最高的 BeanHandler, 查询到的单个数据封装成一个对象 BeanListHandler, 查询到的多个数据封装 成一个List&lt;对象&gt; ArrayHandler, 查询到的单个数据封装成一个数组 ArrayListHandler, 查询到的多个数据封装成一个集合 ，集合里面的元素是数组。 ​​​ MapHandler, 查询到的单个数据封装成一个map​ MapListHandler,查询到的多个数据封装成一个集合 ，集合里面的元素是map。 ColumnListHandlerKeyedHandlerScalarHandler 总结事务使用命令行演示 使用代码演示 脏读、 不可重复读、 幻读丢失更新 悲观锁 乐观锁 4个隔离级别 读未提交 读已提交 可重复读 可串行化 数据连接池 DBCP 不使用配置 使用配置 C3P0 不使用配置 使用配置 （必须掌握） 自定义连接池 装饰者模式 DBUtils 简化了我们的CRUD ， 里面定义了通用的CRUD方法。 queryRunner.update(); queryRunner.query]]></content>
      <categories>
        <category>DataBase</category>
      </categories>
      <tags>
        <tag>DataBase</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10 JSP&EL&JSTL]]></title>
    <url>%2F2018%2F11%2F04%2F%E5%89%8D%E7%AB%AF%2F10.JSP%20EL%20JSTL%2F</url>
    <content type="text"><![CDATA[JSP &amp; EL &amp; JSTLjsp Java Server Page 什么是jsp 从用户角度看待 ，就是是一个网页 ， 从程序员角度看待 ， 其实是一个java类， 它继承了servlet，所以可以直接说jsp 就是一个Servlet. 为什么会有jsp? html 多数情况下用来显示静态内容 ， 一成不变的。 但是有时候我们需要在网页上显示一些动态数据， 比如： 查询所有的学生信息， 根据姓名去查询具体某个学生。 这些动作都需要去查询数据库，然后在网页上显示。 html是不支持写java代码 ， jsp里面可以写java代码。 怎么用JSP指令写法&lt;%@ 指令名字 %&gt; page指令 language 表明jsp页面中可以写java代码 contentType 其实即使说这个文件是什么类型，告诉浏览器我是什么内容类型，以及使用什么编码 contentType=&quot;text/html; charset=UTF-8&quot; text/html MIMEType 这是一个文本，html网页 pageEncoding jsp内容编码 extends 用于指定jsp翻译成java文件后，继承的父类是谁，一般不用改。 import 导包使用的，一般不用手写。 session 值可选的有true or false . 用于控制在这个jsp页面里面，能够直接使用session对象。 具体的区别是，请看翻译后的java文件 如果该值是true , 那么在代码里面会有getSession（）的调用，如果是false : 那么就不会有该方法调用，也就是没有session对象了。在页面上自然也就不能使用session了。 errorPage 指的是错误的页面， 值需要给错误的页面路径 isErrorPage 上面的errorPage 用于指定错误的时候跑到哪一个页面去。 那么这个isErroPage , 就是声明某一个页面到底是不是错误的页面。 include 包含另外一个jsp的内容进来。 &lt;%@ include file=&quot;other02.jsp&quot;%&gt; 背后细节: 把另外一个页面的所有内容拿过来一起输出。 所有的标签元素都包含进来。 taglib &lt;%@ taglib prefix=&quot;&quot; uri=&quot;&quot;%&gt; uri: 标签库路径 prefix : 标签库的别名 JSP 动作标签&lt;jsp:include page=&quot;&quot;&gt;&lt;/jsp:include&gt; &lt;jsp:param value=&quot;&quot; name=&quot;&quot;/&gt; &lt;jsp:forward page=&quot;&quot;&gt;&lt;/jsp:forward&gt; jsp:include &lt;jsp:include page=”other02.jsp”&gt;&lt;/jsp:include&gt; 包含指定的页面， 这里是动态包含。 也就是不把包含的页面所有元素标签全部拿过来输出，而是把它的运行结果拿过来。 jsp:forward &lt;jsp:forward page=&quot;&quot;&gt;&lt;/jsp:forward&gt; 前往哪一个页面。 &lt;% //请求转发 request.getRequestDispatcher(&quot;other02.jsp&quot;).forward(request, response); %&gt; jsp:param 意思是： 在包含某个页面的时候，或者在跳转某个页面的时候，加入这个参数。 ​​ &lt;jsp:forward page=”other02.jsp”&gt;​ &lt;jsp:param value=”beijing” name=”address”/&gt;​ &lt;/jsp:forward&gt;​​ 在other02.jsp中获取参数 &lt;br&gt;收到的参数是：&lt;br&gt; &lt;%= request.getParameter(&quot;address&quot;)%&gt; JSP内置对象 所谓内置对象，就是我们可以直接在jsp页面中使用这些对象。 不用创建。 pageContext request session application 以上4个是作用域对象 , 作用域 表示这些对象可以存值，他们的取值范围有限定。 setAttribute 和 getAttribute 使用作用域来存储数据&lt;br&gt; &lt;% pageContext.setAttribute(&quot;name&quot;, &quot;page&quot;); request.setAttribute(&quot;name&quot;, &quot;request&quot;); session.setAttribute(&quot;name&quot;, &quot;session&quot;); application.setAttribute(&quot;name&quot;, &quot;application&quot;); %&gt; 取出四个作用域中的值&lt;br&gt; &lt;%=pageContext.getAttribute(&quot;name&quot;)%&gt; &lt;%=request.getAttribute(&quot;name&quot;)%&gt; &lt;%=session.getAttribute(&quot;name&quot;)%&gt; &lt;%=application.getAttribute(&quot;name&quot;)%&gt; 作用域范围大小： pageContext -- request --- session -- application 四个作用域的区别 pageContext 【PageContext】 作用域仅限于当前的页面。 还可以获取到其他八个内置对象。 request 【HttpServletRequest】 作用域仅限于一次请求， 只要服务器对该请求做出了响应。 这个域中存的值就没有了。 session 【HttpSession】 作用域限于一次会话（多次请求与响应） 当中。 application 【ServletContext】 整个工程都可以访问， 服务器关闭后就不能访问了。 out 【JspWriter】 response 【HttpServletResponse】 exception 【Throwable】 page 【Object】 —就是这个jsp翻译成的java类的实例对象 config 【ServletConfig】 EL表达式 是为了简化咱们的jsp代码，具体一点就是为了简化在jsp里面写的那些java代码。 写法格式 ${表达式 } 如果从作用域中取值，会先从小的作用域开始取，如果没有，就往下一个作用域取。 一直把四个作用域取完都没有， 就没有显示。 如何使用1. 取出4个作用域中存放的值。&lt;% pageContext.setAttribute(&quot;name&quot;, &quot;page&quot;); request.setAttribute(&quot;name&quot;, &quot;request&quot;); session.setAttribute(&quot;name&quot;, &quot;session&quot;); application.setAttribute(&quot;name&quot;, &quot;application&quot;); %&gt; 按普通手段取值&lt;br&gt; &lt;%= pageContext.getAttribute(&quot;name&quot;)%&gt; &lt;%= request.getAttribute(&quot;name&quot;)%&gt; &lt;%= session.getAttribute(&quot;name&quot;)%&gt; &lt;%= application.getAttribute(&quot;name&quot;)%&gt; &lt;br&gt;使用EL表达式取出作用域中的值&lt;br&gt; ${ pageScope.name } ${ requestScope.name } ${ sessionScope.name } ${ applicationScope.name } 如果域中所存的是数组 &lt;% String [] a = {&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;,&quot;dd&quot;}; pageContext.setAttribute(&quot;array&quot;, a); %&gt; 使用EL表达式取出作用域中数组的值&lt;br&gt; ${array[0] } , ${array[1] },${array[2] },${array[3] } 如果域中锁存的是集合 使用EL表达式取出作用域中集合的值&lt;br&gt; ${li[0] } , ${li[1] },${li[2] },${li[3] } &lt;br&gt;-------------Map数据----------------&lt;br&gt; &lt;% Map map = new HashMap(); map.put(&quot;name&quot;, &quot;zhangsna&quot;); map.put(&quot;age&quot;,18); map.put(&quot;address&quot;,&quot;北京..&quot;); map.put(&quot;address.aa&quot;,&quot;深圳..&quot;); pageContext.setAttribute(&quot;map&quot;, map); %&gt; 取出Map集合的值 &lt;% Map map = new HashMap(); map.put(&quot;name&quot;, &quot;zhangsna&quot;); map.put(&quot;age&quot;,18); map.put(&quot;address&quot;,&quot;北京..&quot;); map.put(&quot;address.aa&quot;,&quot;深圳..&quot;); pageContext.setAttribute(&quot;map&quot;, map); %&gt; 使用EL表达式取出作用域中Map的值&lt;br&gt; ${map.name } , ${map.age } , ${map.address } , ${map[&quot;address.aa&quot;] } 取值细节： 从域中取值。 得先存值。&lt;% //pageContext.setAttribute(&quot;name&quot;, &quot;zhangsan&quot;); session.setAttribute(&quot;name&quot;, &quot;lisi...&quot;); %&gt; 直接指定说了，到这个作用域里面去找这个name${ pageScope.name } //先从page里面找，没有去request找，去session，去application ${ name } 指定从session中取值 ${ sessionScope.name } 取值方式 如果这份值是有下标的，那么直接使用[] &lt;% String [] array = {&quot;aa&quot;,&quot;bb&quot;,&quot;cc&quot;} session.setAttribute(&quot;array&quot;,array); %&gt; ${ array[1] } --&gt; 这里array说的是attribute的name 如果没有下标， 直接使用 .的方式去取 &lt;% User user = new User(&quot;zhangsan&quot;,18); session.setAttribute(&quot;u&quot;, user); %&gt; ${ u.name } , ${ u.age } 一般使用EL表达式，用的比较多的，都是从一个对象中取出它的属性值，比如取出某一个学生的姓名。 EL表达式 的11个内置对象。${ 对象名.成员 } pageContext 作用域相关对象 pageScope requestScope sessionScope applicationScope 头信息相关对象 header headerValues 参数信息相关对象 param paramValues cookie全局初始化参数 initParam JSTL 全称 ： JSP Standard Tag Library jsp标准标签库 简化jsp的代码编写。 替换 &lt;%%&gt; 写法。 一般与EL表达式配合 怎么使用 导入jar文件到工程的WebContent/Web-Inf/lib jstl.jar standard.jar 在jsp页面上，使用taglib 指令，来引入标签库 注意： 如果想支持 EL表达式，那么引入的标签库必须选择1.1的版本，1.0的版本不支持EL表达式。 &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; 常用标签&lt;c:set&gt;&lt;/c:set&gt;&lt;c:if test=””&gt;&lt;/c:if&gt;&lt;c:forEach&gt;&lt;/c:forEach&gt; c:set &lt;!-- 声明一个对象name， 对象的值 zhangsan , 存储到了page（默认） ， 指定是session --&gt; &lt;c:set var=&quot;name&quot; value=&quot;zhangsan&quot; scope=&quot;session&quot;&gt;&lt;/c:set&gt; ${sessionScope.name } c:if 判断test里面的表达式是否满足，如果满足，就执行c:if标签中的输出 ， c:if 是没有else的。 &lt;c:set var=&quot;age&quot; value=&quot;18&quot; &gt;&lt;/c:set&gt; &lt;c:if test=&quot;${ age &gt; 26 }&quot;&gt; 年龄大于了26岁... &lt;/c:if&gt; &lt;c:if test=&quot;${ age &lt;= 26 }&quot;&gt; 年龄小于了26岁... &lt;/c:if&gt; ------------------------------ 定义一个变量名 flag 去接收前面表达式的值，然后存在session域中 &lt;c:if test=&quot;${ age &gt; 26 }&quot; var=&quot;flag&quot; scope=&quot;session&quot;&gt; 年龄大于了26岁... &lt;/c:if&gt; c:forEach 从1 开始遍历到10 ，得到的结果 ，赋值给 i ,并且会存储到page域中， step , 增幅为2， &lt;c:forEach begin=&quot;1&quot; end=&quot;10&quot; var=&quot;i&quot; step=&quot;2&quot;&gt; ${i } &lt;/c:forEach&gt; ----------------------------------------------- &lt;!-- items : 表示遍历哪一个对象，注意，这里必须写EL表达式。 var: 遍历出来的每一个元素用user 去接收。 --&gt; &lt;c:forEach var=&quot;user&quot; items=&quot;${list }&quot;&gt; ${user.name } ----${user.age } &lt;/c:forEach&gt; 学生信息管理系统 需求分析 先写 login.jsp , 并且搭配一个LoginServlet 去获取登录信息。 创建用户表， 里面只要有id , username 和 password 创建UserDao, 定义登录的方法 /** 该dao定义了对用户表的访问规则 */public interface UserDao { /** 这里简单就返回一个Boolean类型， 成功或者失败即可。 ​ 但是开发的时候，登录的方法，一旦成功。这里应该返回该用户的个人信息 @param userName @param password ​ @return true : 登录成功， false : 登录失败。 */ boolean login(String userName , String password); } 创建UserDaoImpl , 实现刚才定义的登录方法。 public class UserDaoImpl implements UserDao { @Override public boolean login(String userName , String password) { Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try { //1. 得到连接对象 conn = JDBCUtil.getConn(); String sql = &quot;select * from t_user where username=? and password=?&quot;; //2. 创建ps对象 ps = conn.prepareStatement(sql); ps.setString(1, userName); ps.setString(2, password); //3. 开始执行。 rs = ps.executeQuery(); //如果能够成功移到下一条记录，那么表明有这个用户。 return rs.next(); } catch (SQLException e) { e.printStackTrace(); }finally { JDBCUtil.release(conn, ps, rs); } return false; } } 在LoginServlet里面访问UserDao， 判断登录结果。 以区分对待 创建stu_list.jsp , 让登录成功的时候跳转过去。 创建学生表 ， 里面字段随意。 定义学生的Dao . StuDao public interface StuDao { /** * 查询出来所有的学生信息 * @return List集合 */ List&lt;Student&gt; findAll(); } 对上面定义的StuDao 做出实现 StuDaoImpl public class StuDaoImpl implements StuDao { @Override public List&lt;Student&gt; findAll() { List&lt;Student&gt; list = new ArrayList&lt;Student&gt;(); Connection conn = null; PreparedStatement ps = null; ResultSet rs = null; try { //1. 得到连接对象 conn = JDBCUtil.getConn(); String sql = &quot;select * from t_stu&quot;; ps = conn.prepareStatement(sql); rs = ps.executeQuery(); ​ //数据多了，用对象装， 对象也多了呢？ 用集合装。 while(rs.next()){ //10 次 ，10个学生 Student stu = new Student(); stu.setId(rs.getInt(&quot;id&quot;)); stu.setAge(rs.getInt(&quot;age&quot;)); stu.setName(rs.getString(&quot;name&quot;)); stu.setGender(rs.getString(&quot;gender&quot;)); stu.setAddress(rs.getString(&quot;address&quot;)); list.add(stu); } } catch (SQLException e) { e.printStackTrace(); }finally { JDBCUtil.release(conn, ps, rs); } return list; } } 在登录成功的时候，完成三件事情。 查询所有的学生 把这个所有的学生集合存储到作用域中。 跳转到stu_list.jsp protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //提交的数据有可能有中文， 怎么处理。 request.setCharacterEncoding(&quot;UTF-8&quot;); response.setContentType(&quot;text/html;charset=utf-8&quot;); //1. 获取客户端提交的信息 String userName = request.getParameter(&quot;username&quot;); String password = request.getParameter(&quot;password&quot;); //2. 去访问dao ， 看看是否满足登录。 UserDao dao = new UserDaoImpl(); boolean isSuccess = dao.login(userName, password); //3. 针对dao的返回结果，做出响应 if(isSuccess){ //response.getWriter().write(&quot;登录成功.&quot;); //1. 查询出来所有的学生信息。 StuDao stuDao = new StuDaoImpl(); List&lt;Student&gt; list = stuDao.findAll(); //2. 先把这个集合存到作用域中。 request.getSession().setAttribute(&quot;list&quot;, list); //2. 重定向 response.sendRedirect(&quot;stu_list.jsp&quot;); }else{ response.getWriter().write(&quot;用户名或者密码错误！&quot;); } } 在stu_list.jsp中，取出域中的集合，然后使用c标签 去遍历集合。 &lt;table border=&quot;1&quot; width=&quot;700&quot;&gt; &lt;tr align=&quot;center&quot;&gt; &lt;td&gt;编号&lt;/td&gt; &lt;td&gt;姓名&lt;/td&gt; &lt;td&gt;年龄&lt;/td&gt; &lt;td&gt;性别&lt;/td&gt; &lt;td&gt;住址&lt;/td&gt; &lt;td&gt;操作&lt;/td&gt; &lt;/tr&gt; &lt;c:forEach items=&quot;${list }&quot; var=&quot;stu&quot;&gt; &lt;tr align=&quot;center&quot;&gt; &lt;td&gt;${stu.id }&lt;/td&gt; &lt;td&gt;${stu.name }&lt;/td&gt; &lt;td&gt;${stu.age }&lt;/td&gt; &lt;td&gt;${stu.gender }&lt;/td&gt; &lt;td&gt;${stu.address }&lt;/td&gt; &lt;td&gt;&lt;a href=&quot;# &quot;&gt;更新&lt;/a&gt; &lt;a href=&quot;# &quot;&gt;删除&lt;/a&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/table&gt; 总结： JSP 三大指令 page include taglib 三个动作标签 &lt;jsp:include&gt; &lt;jsp:forward&gt; &lt;jsp:param&gt; 九个内置对象 四个作用域 pageContext request session application out exception response page config ​ EL ${ 表达式 } 取4个作用域中的值 ${ name } 有11个内置对象。 pageContext pageScope requestScope sessionScope applicationScope header headerValues param paramValues cookie initParam JSTL 使用1.1的版本， 支持EL表达式， 1.0不支持EL表达式 拷贝jar包， 通过taglib 去引入标签库 &lt;c:set&gt; &lt;c:if&gt; &lt;c:forEach&gt; ​]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[9 Cookie&Session]]></title>
    <url>%2F2018%2F11%2F03%2FJ2EE%2F9.Cookie%20Session%2F</url>
    <content type="text"><![CDATA[中文文件下载 针对浏览器类型，对文件名字做编码处理 Firefox (Base64) , IE、Chrome … 使用的是URLEncoder /* * 如果文件的名字带有中文，那么需要对这个文件名进行编码处理 * 如果是IE ，或者 Chrome （谷歌浏览器） ，使用URLEncoding 编码 * 如果是Firefox ， 使用Base64编码 */ //获取来访的客户端类型 String clientType = request.getHeader(&quot;User-Agent&quot;); if(clientType.contains(&quot;Firefox&quot;)){ fileName = DownLoadUtil.base64EncodeFileName(fileName); }else{ //IE ，或者 Chrome （谷歌浏览器） ， //对中文的名字进行编码处理 fileName = URLEncoder.encode(fileName,&quot;UTF-8&quot;); } 请求转发和重定向重定向 /* 之前的写法 response.setStatus(302); response.setHeader(&quot;Location&quot;, &quot;login_success.html&quot;);*/ //重定向写法： 重新定位方向 参数即跳转的位置 response.sendRedirect(&quot;login_success.html&quot;); 1. 地址上显示的是最后的那个资源的路径地址 2. 请求次数最少有两次， 服务器在第一次请求后，会返回302 以及一个地址， 浏览器在根据这个地址，执行第二次访问。 3. 可以跳转到任意路径。 不是自己的工程也可以跳。 4. 效率稍微低一点， 执行两次请求。 5. 后续的请求，没法使用上一次的request存储的数据，或者 没法使用上一次的request对象，因为这是两次不同的请求。 请求转发//请求转发的写法： 参数即跳转的位置 request.getRequestDispatcher(&quot;login_success.html&quot;).forward(request, response); 1. 地址上显示的是请求servlet的地址。 返回200 ok 2. 请求次数只有一次， 因为是服务器内部帮客户端执行了后续的工作。 3. 只能跳转自己项目的资源路径 。 4. 效率上稍微高一点，因为只执行一次请求。 5. 可以使用上一次的request对象。 Cookie 饼干. 其实是一份小数据， 是服务器给客户端，并且存储在客户端上的一份小数据 应用场景 自动登录、浏览记录、购物车。 为什么要有这个Cookie http的请求是无状态。 客户端与服务器在通讯的时候，是无状态的，其实就是客户端在第二次来访的时候，服务器根本就不知道这个客户端以前有没有来访问过。 为了更好的用户体验，更好的交互 [自动登录]，其实从公司层面讲，就是为了更好的收集用户习惯[大数据] Cookie怎么用## 简单使用： 添加Cookie给客户端 在响应的时候，添加cookie Cookie cookie = new Cookie(&quot;aa&quot;, &quot;bb&quot;); ​ ​ //给响应，添加一个cookie response.addCookie(cookie); 客户端收到的信息里面，响应头中多了一个字段 Set-Cookie 获取客户端带过来的Cookie //获取客户端带过来的cookie ​ Cookie[] cookies = request.getCookies(); ​ if(cookies != null){ ​ for (Cookie c : cookies) { ​ String cookieName = c.getName(); ​ String cookieValue = c.getValue(); ​ System.out.println(cookieName + “ = “+ cookieValue); ​ } ​ } 常用方法 //关闭浏览器后，cookie就没有了。 ---&gt; 针对没有设置cookie的有效期。 // expiry： 有效 以秒计算。 //正值 ： 表示 在这个数字过后，cookie将会失效。 //负值： 关闭浏览器，那么cookie就失效， 默认值是 -1 cookie.setMaxAge(60 * 60 * 24 * 7); //赋值新的值 //cookie.setValue(newValue); //用于指定只有请求了指定的域名，才会带上该cookie cookie.setDomain(&quot;.itheima.com&quot;); //只有访问该域名下的cookieDemo的这个路径地址才会带cookie cookie.setPath(&quot;/CookieDemo&quot;); 例子一 显示最近访问的时间。 判断账号是否正确 如果正确，则获取cookie。 但是得到的cookie是一个数组， 我们要从数组里面找到我们想要的对象。 如果找到的对象为空，表明是第一次登录。那么要添加cookie 如果找到的对象不为空， 表明不是第一次登录。 if(&quot;admin&quot;.equals(userName) &amp;&amp; &quot;123&quot;.equals(password)){ //获取cookie last-name --- &gt; Cookie [] cookies = request.getCookies(); //从数组里面找出我们想要的cookie Cookie cookie = CookieUtil.findCookie(cookies, &quot;last&quot;); //是第一次登录，没有cookie if(cookie == null){ Cookie c = new Cookie(&quot;last&quot;, System.currentTimeMillis()+&quot;&quot;); c.setMaxAge(60*60); //一个小时 response.addCookie(c); response.getWriter().write(&quot;欢迎您, &quot;+userName); }else{ //1. 去以前的cookie第二次登录，有cookie long lastVisitTime = Long.parseLong(cookie.getValue()); //2. 输出到界面， response.getWriter().write(&quot;欢迎您, &quot;+userName +&quot;,上次来访时间是：&quot;+new Date(lastVisitTime)); ​​ //3. 重置登录的时间​ cookie.setValue(System.currentTimeMillis()+””);​ response.addCookie(cookie);​ }​ }else{​ response.getWriter().write(“登陆失败 “);​ } 例子二： 显示商品浏览记录。准备工作 拷贝基础课第一天的 htmll原型文件，到工程的WebContent里面。 在WebContent目录下新建一个jsp文件， product_list.jsp, 然后拷贝原来product_list.html的内容到jsp里面。 建好之后，jsp里面的所有ISO-8859-1 改成 UTF-8 拷贝html标签的所有内容。 替换jsp的html标签即可 修改product_info.htm里面的手机数码超链接地址 &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;product_list.jsp&quot;&gt;手机数码&lt;span class=&quot;sr-only&quot;&gt;(current)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; 修改首页(index.html)顶部的手机数码跳转的位置为 product_list.jsp &lt;li class=&quot;active&quot;&gt;&lt;a href=&quot;product_list.jsp&quot;&gt;手机数码&lt;span class=&quot;sr-only&quot;&gt;(current)&lt;/span&gt;&lt;/a&gt;&lt;/li&gt; 分析 Jsp 里面使用Java代码 jsp Java Server Pager —&gt; 最终会翻译成一个类， 就是一个Servlet 定义全局变量 &lt;%! int a = 99; %&gt; 定义局部变量 &lt;% int b = 999; %&gt; 在jsp页面上，显示 a 和 b的值， &lt;%=a %&gt; &lt;%=b %&gt; jsp显示浏览记录 清除浏览记录 其实就是清除Cookie， 删除cookie是没有什么delete方法的。只有设置maxAge 为0 。 Cookie cookie = new Cookie(&quot;history&quot;,&quot;&quot;); cookie.setMaxAge(0); //设置立即删除 cookie.setPath(&quot;/CookieDemo02&quot;); response.addCookie(cookie); Cookie总结 服务器给客户端发送过来的一小份数据，并且存放在客户端上。 获取cookie， 添加cookie request.getCookie(); response.addCookie(); Cookie分类 会话Cookie ​ 默认情况下，关闭了浏览器，那么cookie就会消失。 持久Cookie 在一定时间内，都有效，并且会保存在客户端上。 cookie.setMaxAge(0); //设置立即删除 cookie.setMaxAge(100); //100 秒 Cookie的安全问题。 由于Cookie会保存在客户端上，所以有安全隐患问题。 还有一个问题， Cookie的大小与个数有限制。 为了解决这个问题 —&gt; Session . Session 会话 ， Session是基于Cookie的一种会话机制。 Cookie是服务器返回一小份数据给客户端，并且存放在客户端上。 Session是，数据存放在服务器端。 常用API //得到会话ID String id = session.getId(); //存值 session.setAttribute(name, value); //取值 session.getAttribute(name); //移除值 session.removeAttribute(name); Session何时创建 ， 何时销毁? 创建 如果有在servlet里面调用了 request.getSession() 销毁 session 是存放在服务器的内存中的一份数据。 当然可以持久化. Redis . 即使关了浏览器，session也不会销毁。 关闭服务器 session会话时间过期。 有效期过了，默认有效期： 30分钟。 例子三： 简单购物车。 CartServlet 代码response.setContentType(&quot;text/html;charset=utf-8&quot;); //1. 获取要添加到购物车的商品id int id = Integer.parseInt(request.getParameter(&quot;id&quot;)); // 0 - 1- 2 -3 -4 String [] names = {&quot;Iphone7&quot;,&quot;小米6&quot;,&quot;三星Note8&quot;,&quot;魅族7&quot; , &quot;华为9&quot;}; //取到id对应的商品名称 String name = names[id]; //2. 获取购物车存放东西的session Map&lt;String , Integer&gt; iphoen7 3 //把一个map对象存放到session里面去，并且保证只存一次。 Map&lt;String, Integer&gt; map = (Map&lt;String, Integer&gt;) request.getSession().getAttribute(&quot;cart&quot;); //session里面没有存放过任何东西。 if(map == null){ map = new LinkedHashMap&lt;String , Integer&gt;(); request.getSession().setAttribute(&quot;cart&quot;, map); } ​​ //3. 判断购物车里面有没有该商品​ if(map.containsKey(name)){​ //在原来的值基础上 + 1​ map.put(name, map.get(name) + 1 );​ }else{​ //没有购买过该商品，当前数量为1 。​ map.put(name, 1);​ }​​ //4. 输出界面。（跳转）​ response.getWriter().write(“继续购物“);​ response.getWriter().write(“去购物车结算“); 移除Session中的元素//强制干掉会话，里面存放的任何数据就都没有了。 session.invalidate(); //从session中移除某一个数据 //session.removeAttribute(&quot;cart&quot;); 总结： 请求转发和重定向（面试经常问。） Cookie 服务器给客户端发送一小份数据， 存放在客户端上。 基本用法： 添加cookie 获取cookie。 演练例子： 1. 获取上一次访问时间 2. 获取商品浏览记录。 什么时候有cookie response.addCookie(new Cookie()) Cookie 分类 会话Cookie 关闭浏览器，就失效 持久cookie 存放在客户端上。 在指定的期限内有效。 setMaxAge(); Session 也是基于cookie的一种会话技术， 数据存放存放在服务器端 会在cookie里面添加一个字段 JSESSIONID . 是tomcat服务器生成。 setAttribute 存数据 getAttribute 取数据 removeAttribute 移除数据 getSessionId(); 获取会话id invalidate() 强制让会话失效。 创建和销毁 ，调用request.getSesion创建 服务器关闭 ， 会话超时（30分） setAttribute 存放的值， 在浏览器关闭后，还有没有。 有！，就算客户端把电脑砸了也还有。 ​]]></content>
      <categories>
        <category>J2EE</category>
      </categories>
      <tags>
        <tag>J2EE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[8 Http&Servlet]]></title>
    <url>%2F2018%2F11%2F02%2FJ2EE%2F8.Http%20Servlet%2F</url>
    <content type="text"><![CDATA[Http协议&amp;ServletHttp协议 什么是协议 双方在交互、通讯的时候， 遵守的一种规范、规则。 http协议 针对网络上的客户端 与 服务器端在执行http请求的时候，遵守的一种规范。 其实就是规定了客户端在访问服务器端的时候，要带上哪些东西， 服务器端返回数据的时候，也要带上什么东西。 版本 1.0 请求数据，服务器返回后， 将会断开连接 1.1 请求数据，服务器返回后， 连接还会保持着。 除非服务器 | 客户端 关掉。 有一定的时间限制，如果都空着这个连接，那么后面会自己断掉。 演示客户端 如何 与服务器端通讯。 在地址栏中键入网络地址 回车 或者是平常注册的时候，点击了注册按钮 ， 浏览器都能显示出来一些东西。那么背地里到底浏览器和服务器是怎么通讯。 它们都传输了哪些数据。 安装抓包工具 HttpWatch (IE插件) 打开tomcat. 输入localhost:8080 打开首页 在首页上找到Example 字样 6.x 和 7.x 的文档页面有所不同，但是只要找到example就能够找到例子工程 选择 servlet 例子 —&gt; Request Parameter 接着点击Request Parameters 的 Execute超链接 执行tomcat的例子，然后查看浏览器和 tomcat服务器的对接细节 Http请求数据解释 请求的数据里面包含三个部分内容 ： 请求行 、 请求头 、请求体 请求行 POST /examples/servlets/servlet/RequestParamExample HTTP/1.1 POST ： 请求方式 ，以post去提交数据 /examples/servlets/servlet/RequestParamExample 请求的地址路径 ， 就是要访问哪个地方。 HTTP/1.1 协议版本 请求头 Accept: application/x-ms-application, image/jpeg, application/xaml+xml, image/gif, image/pjpeg, application/x-ms-xbap, */* ​ Referer: http://localhost:8080/examples/servlets/servlet/RequestParamExample ​ Accept-Language: zh-CN ​ User-Agent: Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.1; WOW64; Trident/4.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E) ​ Content-Type: application/x-www-form-urlencoded ​ Accept-Encoding: gzip, deflate ​ Host: localhost:8080 ​ Content-Length: 31 ​ Connection: Keep-Alive ​ Cache-Control: no-cache Accept: 客户端向服务器端表示，我能支持什么类型的数据。 Referer ： 真正请求的地址路径，全路径 Accept-Language: 支持语言格式 User-Agent: 用户代理 向服务器表明，当前来访的客户端信息。 Content-Type： 提交的数据类型。经过urlencoding编码的form表单的数据 Accept-Encoding： gzip, deflate ： 压缩算法 。 Host ： 主机地址 Content-Length： 数据长度 Connection : Keep-Alive 保持连接 Cache-Control ： 对缓存的操作 请求体 浏览器真正发送给服务器的数据 发送的数据呈现的是key=value ,如果存在多个数据，那么使用 &amp; firstname=zhang&amp;lastname=sansan Http响应数据解析 请求的数据里面包含三个部分内容 ： 响应行 、 响应头 、响应体 HTTP/1.1 200 OK Server: Apache-Coyote/1.1 Content-Type: text/html;charset=ISO-8859-1 Content-Length: 673 Date: Fri, 17 Feb 2017 02:53:02 GMT ...这里还有很多数据... 响应行 HTTP/1.1 200 OK 协议版本 状态码 咱们这次交互到底是什么样结果的一个code. 200 : 成功，正常处理，得到数据。 403 : for bidden 拒绝 404 ： Not Found 500 ： 服务器异常 OK 对应前面的状态码 响应头 Server: 服务器是哪一种类型。 Tomcat Content-Type ： 服务器返回给客户端你的内容类型 Content-Length ： 返回的数据长度 Date ： 通讯的日期，响应的时间 Get 和 Post请求区别 post 1. 数据是以流的方式写过去，不会在地址栏上面显示。 现在一般提交数据到服务器使用的都是POST 2. 以流的方式写数据，所以数据没有大小限制。 get 1. 会在地址栏后面拼接数据，所以有安全隐患。 一般从服务器获取数据，并且客户端也不用提交上面数据的时候，可以使用GET 2. 能够带的数据有限， 1kb大小 Web资源在http协议当中，规定了请求和响应双方， 客户端和服务器端。与web相关的资源。 有两种分类 静态资源 html 、 js、 css 动态资源 servlet/jsp Servlet servlet是什么? 其实就是一个java程序，运行在我们的web服务器上，用于接收和响应 客户端的http请求。 更多的是配合动态资源来做。 当然静态资源也需要使用到servlet，只不过是Tomcat里面已经定义好了一个 DefaultServlet Hello Servlet 得写一个Web工程 ， 要有一个服务器。 测试运行Web工程 1. 新建一个类， 实现Servlet接口 2. 配置Servlet ， 用意： 告诉服务器，我们的应用有这么些个servlet。 在webContent/WEB-INF/web.xml里面写上以下内容。 &lt;!-- 向tomcat报告， 我这个应用里面有这个servlet， 名字叫做HelloServlet , 具体的路径是com.itheima.servlet.HelloServlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.itheima.servlet.HelloServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;!-- 注册servlet的映射。 servletName : 找到上面注册的具体servlet， url-pattern: 在地址栏上的path 一定要以/打头 --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;HelloServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/a&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 3. 在地址栏上输入 http://localhost:8080/项目名称/a Servlet执行过程 Servlet的通用写法Servlet (接口) | | GenericServlet | | HttpServlet （用于处理http的请求） 定义一个类，继承HttpServlet 复写doGet 和 doPost Servlet的生命周期 生命周期 从创建到销毁的一段时间 生命周期方法 从创建到销毁，所调用的那些方法。 init方法 在创建该servlet的实例时，就执行该方法。 ​ 一个servlet只会初始化一次， init方法只会执行一次 ​ 默认情况下是 ： 初次访问该servlet，才会创建实例。 service方法 只要客户端来了一个请求，那么就执行这个方法了。 该方法可以被执行很多次。 一次请求，对应一次service方法的调用 destroy方法 servlet销毁的时候，就会执行该方法 ​ ​ 1. 该项目从tomcat的里面移除。 ​ 2. 正常关闭tomcat就会执行 shutdown.bat doGet 和 doPost不算生命周期方法，所谓的生命周期方法是指，从对象的创建到销毁一定会执行的方法， 但是这两个方法，不一定会执行。 让Servlet创建实例的时机 提前。 默认情况下，只有在初次访问servlet的时候，才会执行init方法。 有的时候，我们可能需要在这个方法里面执行一些初始化工作，甚至是做一些比较耗时的逻辑。 那么这个时候，初次访问，可能会在init方法中逗留太久的时间。 那么有没有方法可以让这个初始化的时机提前一点。 在配置的时候， 使用load-on-startup元素来指定， 给定的数字越小，启动的时机就越早。 一般不写负数， 从2开始即可。 &lt;servlet&gt; &lt;servlet-name&gt;HelloServlet04&lt;/servlet-name&gt; &lt;servlet-class&gt;com.itheima.servlet.HelloServlet04&lt;/servlet-class&gt; &lt;load-on-startup&gt;2&lt;/load-on-startup&gt; &lt;/servlet&gt; ServletConfig Servlet的配置，通过这个对象，可以获取servlet在配置的时候一些信息 先说 ， 在写怎么用， 最后说有什么用。 //1. 得到servlet配置对象 专门用于在配置servlet的信息 ServletConfig config = getServletConfig(); //获取到的是配置servlet里面servlet-name 的文本内容 String servletName = config.getServletName(); System.out.println(&quot;servletName=&quot;+servletName); ​​ //2、。 可以获取具体的某一个参数。​ String address = config.getInitParameter(“address”);​ System.out.println(“address=”+address); //3.获取所有的参数名称 Enumeration&lt;String&gt; names = config.getInitParameterNames(); //遍历取出所有的参数名称 while (names.hasMoreElements()) { String key = (String) names.nextElement(); String value = config.getInitParameter(key); System.out.println(&quot;key===&quot;+key + &quot; value=&quot;+value); } 为什么需要有这个ServletConfig 未来我们自己开发的一些应用，使用到了一些技术，或者一些代码，我们不会。 但是有人写出来了。它的代码放置在了自己的servlet类里面。 刚好这个servlet 里面需要一个数字或者叫做变量值。 但是这个值不能是固定了。 所以要求使用到这个servlet的公司，在注册servlet的时候，必须要在web.xml里面，声明init-params 在开发当中比较少用。 刚才的这个实验， 希望基础好或者感兴趣的同学，回去自己做一下。 总结 Http协议 1. 使用HttpWacht 抓包看一看http请求背后的细节。 2. 基本了解 请求和响应的数据内容 请求行、 请求头 、请求体 ​ 响应行、响应头、响应体 3. Get和Post的区别 Servlet【重点】 1. 会使用简单的servlet 1.写一个类，实现接口Servlet ​ 2. 配置Servlet ​ 3. 会访问Setvlet 2. Servlet的生命周期 init 一次 创建对象 默认初次访问就会调用或者可以通过配置，让它提前 load-on-startup service 多次，一次请求对应一次service destory 一次 销毁的时候 从服务器移除 或者 正常关闭服务器 3. ServletConfig 获取配置的信息， params]]></content>
      <categories>
        <category>J2EE</category>
      </categories>
      <tags>
        <tag>J2EE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[7 Xml&Tomcat]]></title>
    <url>%2F2018%2F11%2F01%2FJ2EE%2F7.Xml%20Tomcat%2F</url>
    <content type="text"><![CDATA[Xml &amp; TomcatXml eXtendsible markup language 可扩展的标记语言 XML 有什么用? 可以用来保存数据 可以用来做配置文件 数据传输载体 定义xml 其实就是一个文件，文件的后缀为 .xml . 文档声明简单声明， version : 解析这个xml的时候，使用什么版本的解析器解析 &lt;?xml version=&quot;1.0&quot; ?&gt; encoding : 解析xml中的文字的时候，使用什么编码来翻译 &lt;?xml version=&quot;1.0&quot; encoding=&quot;gbk&quot; ?&gt; standalone : no - 该文档会依赖关联其他文档 ， yes-- 这是一个独立的文档 &lt;?xml version=&quot;1.0&quot; encoding=&quot;gbk&quot; standalone=&quot;no&quot; ?&gt; encoding详解 在解析这个xml的时候，使用什么编码去解析。 —解码。 文字， 而是存储这些文字对应的二进制 。 那么这些文字对应的二进制到底是多少呢？ 根据文件使用的编码 来得到。 默认文件保存的时候，使用的是GBK的编码保存。 所以要想让我们的xml能够正常的显示中文，有两种解决办法 让encoding也是GBK 或者 gb2312 . 如果encoding是 utf-8 ， 那么保存文件的时候也必须使用utf-8 保存的时候见到的ANSI 对应的其实是我们的本地编码 GBK。 为了通用，建议使用UTF-8编码保存，以及encoding 都是 utf-8 元素定义（标签） 其实就是里面的标签， &lt;&gt; 括起来的都叫元素 。 成对出现。 如下： &lt;stu&gt; &lt;/stu&gt; 文档声明下来的第一个元素叫做根元素 (根标签) 标签里面可以嵌套标签 空标签 既是开始也是结束。 一般配合属性来用。 &lt;age/&gt; &lt;stu&gt; &lt;name&gt;张三&lt;/name&gt; &lt;age/&gt; &lt;/stu&gt; 标签可以自定义。 XML 命名规则​ XML 元素必须遵循以下命名规则： 名称可以含字母、数字以及其他的字符 名称不能以数字或者标点符号开始 名称不能以字符 “xml”（或者 XML、Xml）开始 名称不能包含空格 命名尽量简单，做到见名知义 简单元素 &amp; 复杂元素 简单元素 元素里面包含了普通的文字 复杂元素 元素里面还可以嵌套其他的元素 属性的定义 定义在元素里面， &lt;元素名称 属性名称=”属性的值”&gt;&lt;/元素名称&gt; ​ ​ ​ 张三 ​ 18 ​ ​ ​ 李四 ​ 28 ​ ​ xml注释： 与html的注释一样。 &lt;!-- --&gt; 如： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!-- //这里有两个学生 //一个学生，名字叫张三， 年龄18岁， 学号：10086 //另外一个学生叫李四 。。。 --&gt; xml的注释，不允许放置在文档的第一行。 必须在文档声明的下面。 CDATA区 非法字符 严格地讲，在 XML 中仅有字符 “&lt;”和”&amp;” 是非法的。省略号、引号和大于号是合法的，但是把它们替换为实体引用是个好的习惯。 &lt; &lt;&amp; &amp; 如果某段字符串里面有过多的字符， 并且里面包含了类似标签或者关键字的这种文字，不想让xml的解析器去解析。 那么可以使用CDATA来包装。 不过这个CDATA 一般比较少看到。 通常在服务器给客户端返回数据的时候。 &lt;des&gt;&lt;![CDATA[&lt;a href=&quot;http://www.baidu.com&quot;&gt;我爱黑马训练营&lt;/a&gt;]]&gt;&lt;/des&gt; XML 解析 其实就是获取元素里面的字符数据或者属性数据。 XML解析方式(面试常问) 有很多种，但是常用的有两种。 DOM SAX 针对这两种解析方式的API 一些组织或者公司， 针对以上两种解析方式， 给出的解决方案有哪些？ jaxp sun公司。 比较繁琐 jdom dom4j 使用比较广泛 Dom4j 基本用法element.element(&quot;stu&quot;) : 返回该元素下的第一个stu元素 element.elements(); 返回该元素下的所有子元素。 创建SaxReader对象 指定解析的xml 获取根元素。 根据根元素获取子元素或者下面的子孙元素 try { //1. 创建sax读取对象 SAXReader reader = new SAXReader(); //jdbc -- classloader //2. 指定解析的xml源 Document document = reader.read(new File(&quot;src/xml/stus.xml&quot;)); //3. 得到元素、 //得到根元素 Element rootElement= document.getRootElement(); //获取根元素下面的子元素 age //rootElement.element(&quot;age&quot;) //System.out.println(rootElement.element(&quot;stu&quot;).element(&quot;age&quot;).getText()); //获取根元素下面的所有子元素 。 stu元素 List&lt;Element&gt; elements = rootElement.elements(); //遍历所有的stu元素 for (Element element : elements) { //获取stu元素下面的name元素 String name = element.element(&quot;name&quot;).getText(); String age = element.element(&quot;age&quot;).getText(); String address = element.element(&quot;address&quot;).getText(); System.out.println(&quot;name=&quot;+name+&quot;==age+&quot;+age+&quot;==address=&quot;+address); } } catch (Exception e) { e.printStackTrace(); } SaxReader 创建好对象 。 DocumentElement 看文档 记住关键字 。 有对象先点一下。 看一下方法的返回值。 根据平时的积累。 getXXX setXXX Dom4j 的 Xpath使用 dom4j里面支持Xpath的写法。 xpath其实是xml的路径语言，支持我们在解析xml的时候，能够快速的定位到具体的某一个元素。 添加jar包依赖 jaxen-1.1-beta-6.jar 在查找指定节点的时候，根据XPath语法规则来查找 后续的代码与以前的解析代码一样。 //要想使用Xpath， 还得添加支持的jar 获取的是第一个 只返回一个。 Element nameElement = (Element) rootElement.selectSingleNode(&quot;//name&quot;); System.out.println(nameElement.getText()); System.out.println(&quot;----------------&quot;); //获取文档里面的所有name元素 List&lt;Element&gt; list = rootElement.selectNodes(&quot;//name&quot;); for (Element element : list) { System.out.println(element.getText()); } XML 约束【了解】如下的文档， 属性的ID值是一样的。 这在生活中是不可能出现的。 并且第二个学生的姓名有好几个。 一般也很少。那么怎么规定ID的值唯一， 或者是元素只能出现一次，不能出现多次？ 甚至是规定里面只能出现具体的元素名字。 &lt;stus&gt; &lt;stu id=&quot;10086&quot;&gt; &lt;name&gt;张三&lt;/name&gt; &lt;age&gt;18&lt;/age&gt; &lt;address&gt;深圳&lt;/address&gt; &lt;/stu&gt; &lt;stu id=&quot;10086&quot;&gt; &lt;name&gt;李四&lt;/name&gt; &lt;name&gt;李五&lt;/name&gt; &lt;name&gt;李六&lt;/name&gt; &lt;age&gt;28&lt;/age&gt; &lt;address&gt;北京&lt;/address&gt; &lt;/stu&gt; &lt;/stus&gt; DTD语法自成一派， 早起就出现的。 可读性比较差。 引入网络上的DTD &lt;!-- 引入dtd 来约束这个xml --&gt; &lt;!-- 文档类型 根标签名字 网络上的dtd dtd的名称 dtd的路径 &lt;!DOCTYPE stus PUBLIC &quot;//UNKNOWN/&quot; &quot;unknown.dtd&quot;&gt; --&gt; 引入本地的DTD 直接在XML里面嵌入DTD的约束规则 &lt;!-- xml文档里面直接嵌入DTD的约束法则 --&gt; &lt;!DOCTYPE stus [ &lt;!ELEMENT stus (stu)&gt; &lt;!ELEMENT stu (name,age)&gt; &lt;!ELEMENT name (# PCDATA)&gt; &lt;!ELEMENT age (# PCDATA)&gt; ]&gt; &lt;stus&gt; &lt;stu&gt; &lt;name&gt;张三&lt;/name&gt; &lt;age&gt;18&lt;/age&gt; &lt;/stu&gt; &lt;/stus&gt; &lt;!ELEMENT stus (stu)&gt; : stus 下面有一个元素 stu ， 但是只有一个 &lt;!ELEMENT stu (name , age)&gt; stu下面有两个元素 name ,age 顺序必须name-age &lt;!ELEMENT name (# PCDATA)&gt; &lt;!ELEMENT age (# PCDATA)&gt; &lt;!ATTLIST stu id CDATA # IMPLIED&gt; stu有一个属性 文本类型， 该属性可有可无 元素的个数： ＋ 一个或多个 * 零个或多个 ? 零个或一个 属性的类型定义 CDATA : 属性是普通文字 ID : 属性的值必须唯一 &lt;!ELEMENT stu (name , age)&gt; 按照顺序来 &lt;!ELEMENT stu (name | age)&gt; 两个中只能包含一个子元素 Schema其实就是一个xml ， 使用xml的语法规则， xml解析器解析起来比较方便 ， 是为了替代DTD 。 但是Schema 约束文本内容比DTD的内容还要多。 所以目前也没有真正意义上的替代DTD 约束文档： &lt;!-- xmlns : xml namespace : 名称空间 / 命名空间 targetNamespace : 目标名称空间 。 下面定义的那些元素都与这个名称空间绑定上。 elementFormDefault ： 元素的格式化情况。 --&gt; &lt;schema xmlns=&quot;http://www.w3.org/2001/XMLSchema&quot; targetNamespace=&quot;http://www.itheima.com/teacher&quot; elementFormDefault=&quot;qualified&quot;&gt; &lt;element name=&quot;teachers&quot;&gt; &lt;complexType&gt; &lt;sequence maxOccurs=&quot;unbounded&quot;&gt; &lt;!-- 这是一个复杂元素 --&gt; &lt;element name=&quot;teacher&quot;&gt; &lt;complexType&gt; &lt;sequence&gt; &lt;!-- 以下两个是简单元素 --&gt; &lt;element name=&quot;name&quot; type=&quot;string&quot;&gt;&lt;/element&gt; &lt;element name=&quot;age&quot; type=&quot;int&quot;&gt;&lt;/element&gt; &lt;/sequence&gt; &lt;/complexType&gt; &lt;/element&gt; &lt;/sequence&gt; &lt;/complexType&gt; &lt;/element&gt; &lt;/schema&gt; 实例文档： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!-- xmlns:xsi : 这里必须是这样的写法，也就是这个值已经固定了。 xmlns : 这里是名称空间，也固定了，写的是schema里面的顶部目标名称空间 xsi:schemaLocation : 有两段： 前半段是名称空间，也是目标空间的值 ， 后面是约束文档的路径。 --&gt; &lt;teachers xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://www.itheima.com/teacher&quot; xsi:schemaLocation=&quot;http://www.itheima.com/teacher teacher.xsd&quot; &gt; &lt;teacher&gt; &lt;name&gt;zhangsan&lt;/name&gt; &lt;age&gt;19&lt;/age&gt; &lt;/teacher&gt; &lt;teacher&gt; &lt;name&gt;lisi&lt;/name&gt; &lt;age&gt;29&lt;/age&gt; &lt;/teacher&gt; &lt;teacher&gt; &lt;name&gt;lisi&lt;/name&gt; &lt;age&gt;29&lt;/age&gt; &lt;/teacher&gt; &lt;/teachers&gt; 名称空间的作用一个xml如果想指定它的约束规则， 假设使用的是DTD ，那么这个xml只能指定一个DTD ， 不能指定多个DTD 。 但是如果一个xml的约束是定义在schema里面，并且是多个schema，那么是可以的。简单的说： 一个xml 可以引用多个schema约束。 但是只能引用一个DTD约束。 名称空间的作用就是在 写元素的时候，可以指定该元素使用的是哪一套约束规则。 默认情况下 ，如果只有一套规则，那么都可以这么写 &lt;name&gt;张三&lt;/name&gt; &lt;aa:name&gt;&lt;/aa:name&gt; &lt;bb:name&gt;&lt;/bb:name&gt; 程序架构网页游戏 C/S(client/server) QQ 微信 LOL 优点： 有一部分代码写在客户端， 用户体验比较好。 缺点： 服务器更新，客户端也要随着更新。 占用资源大。 B/S(browser/server) 网页游戏 ， WebQQ … 优点： 客户端只要有浏览器就可以了。 占用资源小， 不用更新。 缺点： 用户体验不佳。 服务器 其实服务器就是一台电脑。 配置比一般的要好。 Web服务器软件 客户端在浏览器的地址栏上输入地址 ，然后web服务器软件，接收请求，然后响应消息。处理客户端的请求， 返回资源 | 信息 Web应用 需要服务器支撑。 index.html Tomcat apache WebLogic BEA Websphere IBM IIS 微软 Tomcat安装 直接解压 ，然后找到bin/startup.bat 可以安装 启动之后，如果能够正常看到黑窗口，表明已经成功安装。 为了确保万无一失， 最好在浏览器的地址栏上输入 ： http://localhost:8080 , 如果有看到内容 就表明成功了。 如果双击了startup.bat, 看到一闪而过的情形，一般都是 JDK的环境变量没有配置。 Tomcat目录介绍bin## &gt; 包含了一些jar , bat文件 。 startup.bat conf##​​ tomcat的配置 server.xml web.xml lib tomcat运行所需的jar文件 logs 运行的日志文件 temp 临时文件 webapps## 发布到tomcat服务器上的项目，就存放在这个目录。 work(目前不用管) jsp翻译成class文件存放地 ​ 如何把一个项目发布到tomcat中 需求： 如何能让其他的电脑访问我这台电脑上的资源 。 stu.xml localhost : 本机地址 1. 拷贝这个文件到webapps/ROOT底下， 在浏览器里面访问： http://localhost:8080/stu.xml * 在webaps下面新建一个文件夹xml , 然后拷贝文件放置到这个文件夹中 ​​ http://localhost:8080/xml/stu.xml http://localhost:8080 ： 其实对应的是到webapps/root http://localhost:8080/xml/ : 对应是 webapps/xml 使用IP地址访问： http://192.168.37.48:8080/xml/stu.xml 2. 配置虚拟路径使用localhost：8080 打开tomcat首页， 在左侧找到tomcat的文档入口， 点击进去后， 在左侧接着找到 Context入口，点击进入。 http://localhost:8080/docs/config/context.html 在conf/server.xml 找到host元素节点。 加入以下内容。 &lt;!-- docBase ： 项目的路径地址 如： D:\xml02\person.xml path : 对应的虚拟路径 一定要以/打头。 对应的访问方式为： http://localhost:8080/a/person.xml --&gt; &lt;Context docBase=&quot;D:\xml02&quot; path=&quot;/a&quot;&gt;&lt;/Context&gt; 在浏览器地址栏上输入： http://localhost:8080/a/person.xml 3. 配置虚拟路径 在tomcat/conf/catalina/localhost/ 文件夹下新建一个xml文件，名字可以自己定义。 person.xml 在这个文件里面写入以下内容 &lt;?xml version=&apos;1.0&apos; encoding=&apos;utf-8&apos;?&gt; &lt;Context docBase=&quot;D:\xml02&quot;&gt;&lt;/Context&gt; 在浏览器上面访问 http://localhost:8080/person/xml的名字即可 给Eclipse配置Tomcat 在server里面 右键新建一个服务器， 选择到apache分类， 找到对应的tomcat版本， 接着一步一步配置即可。 配置完毕后， 在server 里面， 右键刚才的服务器，然后open ， 找到上面的Server Location , 选择中间的 Use Tomcat installation… 创建web工程， 在WebContent下定义html文件， 右键工程， run as server 总结：xml 1. 会定义xml 2. 会解析xml dom4j 基本解析 Xpath手法 tomcat 1. 会安装 ，会启动 ， 会访问。 2. 会设置虚拟路径 3. 给eclipse配置tomcat ​]]></content>
      <categories>
        <category>J2EE</category>
      </categories>
      <tags>
        <tag>J2EE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JDBC]]></title>
    <url>%2F2018%2F10%2F28%2FJ2EE%2F6.JDBC%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[JDBC JAVA Database Connectivity java 数据库连接 为什么会出现JDBC SUN公司提供的一种数据库访问规则、规范, 由于数据库种类较多，并且java语言使用比较广泛，sun公司就提供了一种规范，让其他的数据库提供商去实现底层的访问规则。 我们的java程序只要使用sun公司提供的jdbc驱动即可。 使用JDBC的基本步骤 注册驱动 1DriverManager.registerDriver(new com.mysql.jdbc.Driver()); 建立连接 123//DriverManager.getConnection("jdbc:mysql://localhost/test?user=monty&amp;password=greatsqldb");//2. 建立连接 参数一： 协议 + 访问的数据库 ， 参数二： 用户名 ， 参数三： 密码。conn = DriverManager.getConnection("jdbc:mysql://localhost/student", "root", "root"); 创建statement 运输车 12//3. 创建statement ， 跟数据库打交道，一定需要这个对象st = conn.createStatement(); 执行sql ，得到ResultSet 123//4. 执行查询 ， 得到结果集String sql = "select * from t_stu";rs = st.executeQuery(sql); 遍历结果集 1234567//5. 遍历查询每一条记录while(rs.next())&#123; int id = rs.getInt("id"); String name = rs.getString("name"); int age = rs.getInt("age"); System.out.println("id="+id + "===name="+name+"==age="+age);&#125; 释放资源 1234567if (rs != null) &#123; try &#123; rs.close(); &#125; catch (SQLException sqlEx) &#123; &#125; // ignore rs = null;&#125; JDBC 工具类构建 资源释放工作的整合12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//释放结果集private static void closeRs(ResultSet rs) &#123; try &#123; if (rs != null) &#123; rs.close(); &#125; &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; finally &#123; rs = null; &#125;&#125;//释放SQL语句运输车private static void closeSt(Statement st) &#123; try &#123; if (st != null) &#123; st.close(); &#125; &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; finally &#123; st = null; &#125;&#125;//释放连接private static void closeConn(Connection conn) &#123; try &#123; if (conn != null) &#123; conn.close(); &#125; &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; finally &#123; conn = null; &#125;&#125;//总释放public static void release(Connection conn, Statement st, ResultSet rs) &#123; closeRs(rs); closeConn(conn); closeSt(st);&#125;//总释放（无结果集）public static void release(Connection conn, Statement st) &#123; closeConn(conn); closeSt(st);&#125; 驱动防二次注册 1234//Driver 这个类里面有静态代码块，一上来就执行了，所以等同于我们注册了两次驱动。 其实没这个必要的。//静态代码块 ---&gt; 类加载了，就执行 DriverManager.registerDriver(new com.mysql.jdbc.Driver()); java.sql.DriverManager.registerDriver(new Driver()); 最后形成以下代码即可。 1Class.forName("com.mysql.jdbc.Driver"); 使用properties配置文件 在src底下声明一个文件 xxx.properties ，里面的内容吐下： 1234driverClass=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost/studentname=rootpassword=root 在工具类里面，使用静态代码块，读取属性 12345678910111213141516171819202122//JDBCUtil.java static&#123; try &#123; //1. 创建一个属性配置对象 Properties properties = new Properties(); InputStream is = new FileInputStream("jdbc.properties"); //对应文件位于工程根目录 //使用类加载器，去读取src底下的资源文件。 后面在servlet //对应文件位于src目录底下 //InputStream is = JDBCUtil.class.getClassLoader().getResourceAsStream("jdbc.properties"); //导入输入流。 properties.load(is); //读取属性 driverClass = properties.getProperty("driverClass"); url = properties.getProperty("url"); name = properties.getProperty("name"); password = properties.getProperty("password"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; ​ 数据库的CRUD sql Create-添加 Retrieve-读取查询 Update-更新 Delete-删除 insert 1INSERT INTO t_stu VALUES (NULL,'wangqiang2',28) 123456789101112131415 // 1. 获取连接对象conn = JDBCUtil.getConn();// 2. 根据连接对象，得到statementst = conn.createStatement();//3. 执行添加String sql = "insert into t_stu values(null , 'aobama' , 59)";//影响的行数， ，如果大于0 表明操作成功。 否则失败int result = st.executeUpdate(sql);if(result &gt;0 )&#123; System.out.println("添加成功");&#125;else&#123; System.out.println("添加失败");&#125; delete 1DELETE FROM t_stu WHERE id = 6 123456789101112131415// 1. 获取连接对象conn = JDBCUtil.getConn();// 2. 根据连接对象，得到statementst = conn.createStatement(); //3. 执行添加String sql = "delete from t_stu where name='aobama'";//影响的行数， ，如果大于0 表明操作成功。 否则失败int result = st.executeUpdate(sql); if(result &gt;0 )&#123; System.out.println("删除成功");&#125;else&#123; System.out.println("删除失败");&#125; query 1SELECT * FROM t_stu 123456789101112131415// 1. 获取连接对象conn = JDBCUtil.getConn();// 2. 根据连接对象，得到statementst = conn.createStatement();// 3. 执行sql语句，返回ResultSetString sql = "select * from t_stu";rs = st.executeQuery(sql);// 4. 遍历结果集while (rs.next()) &#123; String name = rs.getString("name"); int age = rs.getInt("age"); System.out.println(name + " " + age);&#125; update 1UPDATE t_stu SET age = 38 WHERE id = 1; 123456789101112131415// 1. 获取连接对象conn = JDBCUtil.getConn();// 2. 根据连接对象，得到statementst = conn.createStatement();//3. 执行添加String sql = "update t_stu set age = 26 where name ='qyq'";//影响的行数， ，如果大于0 表明操作成功。 否则失败int result = st.executeUpdate(sql);if(result &gt;0 )&#123; System.out.println("更新成功");&#125;else&#123; System.out.println("更新失败");&#125;###使用单元测试，测试代码 测试类Test-JUnit工具 定义一个类， TestXXX , 里面定义方法 testXXX. 添加junit的支持。 右键工程 — add Library — Junit — Junit4 在方法的上面加上注解 ， 其实就是一个标记。 1234@Testpublic void testQuery() &#123; ...&#125; 光标选中方法名字，然后右键执行单元测试。 或者是打开outline视图， 然后选择方法右键执行。 Dao模式 Data Access Object 数据访问对象 新建一个dao的接口， 里面声明数据库访问规则 1234567891011121314151617181920212223242526272829303132333435public interface UserDao &#123; //update t_user set name=? where id = ? /** * 根据id去更新具体的用户名 * @param id * @param name */ void update(int id , String name); void delete(int id); /** * 执行添加 * @param userName * @param password */ void insert(String userName , String password); /** * 查询所有 */ void findAll(); /** * 登录方法 * @param username * @param password */ void login(String username , String password);&#125; 新建一个dao的实现类，具体实现早前定义的规则 123456789101112131415161718192021222324252627282930 public class UserDaoImpl implements UserDao&#123; @Override public void findAll() &#123; Connection conn = null; Statement st = null; ResultSet rs = null; try &#123; //1. 获取连接对象 conn = JDBCUtil.getConn(); //2. 创建statement对象 st = conn.createStatement(); String sql = "select * from t_user"; rs = st.executeQuery(sql); while(rs.next())&#123; String userName = rs.getString("username"); String password = rs.getString("password"); System.out.println(userName+"="+password); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; JDBCUtil.release(conn, st, rs); &#125; &#125;&#125; 直接使用实现 12345@Test public void testFindAll()&#123; UserDao dao = new UserDaoImpl(); dao.findAll(); &#125; Statement安全问题 Statement执行 ，其实是拼接sql语句的。 先拼接sql语句，然后在一起执行。 123456789String sql = "select * from t_user where username='"+ username +"' and password='"+ password +"'";UserDao dao = new UserDaoImpl();dao.login("admin", "100234khsdf88' or '1=1");SELECT * FROM t_user WHERE username='admin' AND PASSWORD='100234khsdf88' or '1=1' 前面先拼接sql语句， 如果变量里面带有了 数据库的关键字，那么一并认为是关键字。 不认为是普通的字符串。 rs = st.executeQuery(sql); PrepareStatement 该对象就是替换前面的statement对象。 相比较以前的statement， 预先处理给定的sql语句，对其执行语法检查。 在sql语句里面使用 ? 占位符来替代后续要传递进来的变量。 后面进来的变量值，将会被看成是字符串，不会产生任何的关键字。 123456String sql = "insert into t_user values(null , ? , ?)"; ps = conn.prepareStatement(sql); //给占位符赋值 从左到右数过来，1 代表第一个问号， 永远你是1开始。 ps.setString(1, userName); ps.setString(2, password); PrepareStatement相比Statement的优势*​ PrepareStatement用于于处理多条相似的语句，只需修改参数即可 ​ Statement用于处理单条语句，单处理语句 时间方面：​ 处理单条语句的时候 Statement效率较高 ​ 处理多条语句的时候 PreStatement的效率较高 因为有提前预处理 总结： JDBC入门 抽取工具类 Statement CRUD 演练crud Dao模式 声明与实现分开 PrepareStament CRUD 预处理sql语句，解决上面statement出现的问题]]></content>
      <categories>
        <category>J2EE</category>
      </categories>
      <tags>
        <tag>J2EE</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F1970%2F01%2F01%2FWeb%E5%BC%80%E5%8F%91%2FWeb%E5%BC%80%E5%8F%91%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[Restful和RPC的区别 什么是RESTful架构： 每一个URI代表一种资源； 客户端和服务器之间，传递这种资源的某种表现层； 客户端通过四个HTTP动词，对服务器端资源进行操作，实现”表现层状态转化”。 Ngxin的多路复用 异步阻塞I/O：带有阻塞通知的非阻塞I/O]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F1970%2F01%2F01%2F%E5%B9%B6%E5%8F%91%2F%E9%92%88%E5%AF%B9%E5%B9%B6%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[死锁死锁发生的情形 一个线程两次申请锁 两个线程互相申请对方的锁，但是对方都不释放锁 产生死锁的条件与破坏条件的方式 互斥：一个资源每次只能被一个进程使用 无法解决，互斥是设备的固有属性，有了互斥才能保证每个进程对资源的顺利占有使用 请求与保持：一个进程因请求资源而阻塞，对已获得的资源保持不放 要求进程一次性获取所有资源，保证进程的运行的顺利执行，效率较低 不剥夺：进程已获得的资源，在未使用完之外，不能强行剥夺 当某进程所需新的资源被其他进程占有时，释放已占有资源 循环等待：若干进程之间形成一种头尾相接的循环等待资源关系 通过定义资源类型，使其根据类型来顺序执行，效率较低 处理死锁的四种方法 死锁预防：通过确保死锁的一个必要条件不会满足，预防死锁 四个破坏条件的方式，即预防死锁 死锁避免：防止系统进入不安全状态-可能产生死锁的状态即不安全状态 进程启动拒绝和资源分配拒绝（银行家算法，采用资源分配拒绝） https://blog.csdn.net/cout_sev/article/details/24980627 https://blog.csdn.net/qq_33414271/article/details/80245715 死锁检测：允许死锁的发生，通过系统设置的检测机制来检测死锁的发生，通常与死锁解除搭配使用 通过资源分配表来实现 死锁解除：通常与死锁检测搭配使用，已监测到了死锁，通过挂起进程或者撤销进程的形式，回收资源加以分配 资源剥夺法和撤销进程法 并发编程的挑战并发编程的目的为了让程序运行的更快，希望通过多线程执行任务让程序运行得更快，但会面临非常多的挑战，比如上下文切换问题、死锁问题，以及受限于硬件和软件的资源限制问题 上下文切换任务从保存到再次加载的过程就是一次上下文切换，关键字：时间片，状态保存，状态再次加载 单核处理器也支持多线程执行代码，CPU通过给每个线程分配CPU时间片来实现这个机制。时间片是CPU分配给各个线程的时间，因为时间片非常短，所以CPU通过不停地切换线程执行，让我们感觉是多个线程在同时执行，时间片一般为几十毫秒 CPU通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务，切换前会保存上一个任务的状态，以便下次切换回这个任务，可以恢复原来的状态。所以任务从保存到再次加载的过程就是一次上下文切换 多线程（并发）就一定比串行要快吗不一定，当并发执行操作未超过一定次数的时候，串行的执行速度是比并发要快的，因为并发执行需要频繁的创建线程与上下文切换]]></content>
  </entry>
</search>
